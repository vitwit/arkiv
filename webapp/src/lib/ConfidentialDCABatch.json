{
  "address": "0x0765D126B0956975cF55dB84563b817936bfEc6f",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_usdc",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "batchId",
          "type": "uint256"
        }
      ],
      "name": "BatchAlreadyExecuted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        }
      ],
      "name": "CancelRequestAlreadyProcessed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "ERC20TransferFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "ERC20TransferReverted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "ERC20TransferUnknownError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "HandlesAlreadySavedForRequestID",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "provided",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "expected",
          "type": "address"
        }
      ],
      "name": "InvalidFromToken",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidKMSSignatures",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "enum PlanStatus",
          "name": "current",
          "type": "uint8"
        },
        {
          "internalType": "enum PlanStatus",
          "name": "expected",
          "type": "uint8"
        }
      ],
      "name": "InvalidPlanStatus",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        }
      ],
      "name": "InvalidWithdrawRequest",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "pairKey",
          "type": "bytes32"
        }
      ],
      "name": "NoEligiblePlans",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoHandleFoundForRequestID",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "NotPlanOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        }
      ],
      "name": "PairAlreadyExists",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "fromToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "toToken",
          "type": "address"
        }
      ],
      "name": "PairNotAllowed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        }
      ],
      "name": "PairNotFound",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "planId",
          "type": "uint256"
        }
      ],
      "name": "PlanNotFound",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ReentrancyGuardReentrantCall",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "RefundFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "RefundReverted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "RefundUnknownError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        }
      ],
      "name": "RequestAlreadyProcessed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        }
      ],
      "name": "RequestAlreadyProcessing",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        }
      ],
      "name": "UnknownBatchRequest",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnsupportedHandleType",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "batchId",
          "type": "uint256"
        }
      ],
      "name": "ZeroBatchInput",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "batchId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "name": "BatchExecuted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "batchId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "toToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "planCount",
          "type": "uint256"
        }
      ],
      "name": "BatchTriggered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "requestID",
          "type": "uint256"
        }
      ],
      "name": "DecryptionFulfilled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "executor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "allowed",
          "type": "bool"
        }
      ],
      "name": "ExecutorSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "fromToken",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "toToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "allowed",
          "type": "bool"
        }
      ],
      "name": "PairUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "planId",
          "type": "uint256"
        }
      ],
      "name": "PlanCancelled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "planId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "PlanCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "planId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "euint64",
          "name": "amount",
          "type": "bytes32"
        }
      ],
      "name": "PlanDeposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "TransferCompleted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "TransferFailed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "BATCH_LIMIT",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "USDC",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "_escrow",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "_refund",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "allPairs",
      "outputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "fromName",
          "type": "string"
        },
        {
          "internalType": "uint8",
          "name": "fromDecimals",
          "type": "uint8"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "toName",
          "type": "string"
        },
        {
          "internalType": "uint8",
          "name": "toDecimals",
          "type": "uint8"
        },
        {
          "internalType": "bool",
          "name": "allowed",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        }
      ],
      "name": "allowedPairs",
      "outputs": [
        {
          "internalType": "bool",
          "name": "allowed",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "batchReqIdToBatchId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "batches",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "batchId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "fromToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "toToken",
          "type": "address"
        },
        {
          "internalType": "euint64",
          "name": "totalInEnc",
          "type": "bytes32"
        },
        {
          "internalType": "uint64",
          "name": "slotTime",
          "type": "uint64"
        },
        {
          "internalType": "bool",
          "name": "executed",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "planId",
          "type": "uint256"
        }
      ],
      "name": "cancelPlan",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "cancelReqIdToSender",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "cancelRequestIdToPlanId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "cancelRequestProcessed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "toToken",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "startTime",
          "type": "uint64"
        },
        {
          "internalType": "externalEuint64",
          "name": "encInterval",
          "type": "bytes32"
        },
        {
          "internalType": "externalEuint64",
          "name": "encTotalAmount",
          "type": "bytes32"
        },
        {
          "internalType": "externalEuint64",
          "name": "encAmountPerInterval",
          "type": "bytes32"
        },
        {
          "internalType": "externalEuint64",
          "name": "encTotalIntervals",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "proofs",
          "type": "bytes"
        }
      ],
      "name": "createPlan",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "planId",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "planId",
          "type": "uint256"
        }
      ],
      "name": "depositToPlan",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "executors",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAllPairs",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "fromName",
              "type": "string"
            },
            {
              "internalType": "uint8",
              "name": "fromDecimals",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "string",
              "name": "toName",
              "type": "string"
            },
            {
              "internalType": "uint8",
              "name": "toDecimals",
              "type": "uint8"
            },
            {
              "internalType": "bool",
              "name": "allowed",
              "type": "bool"
            }
          ],
          "internalType": "struct Pair[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "nextPlanId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "decryptedValue",
          "type": "uint256"
        },
        {
          "internalType": "bytes[]",
          "name": "signatures",
          "type": "bytes[]"
        }
      ],
      "name": "onBatchAmount",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "decryptedAmount",
          "type": "uint64"
        },
        {
          "internalType": "bytes[]",
          "name": "signatures",
          "type": "bytes[]"
        }
      ],
      "name": "onCancelPlanDecrypt",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        },
        {
          "internalType": "uint64",
          "name": "decryptedAmount",
          "type": "uint64"
        },
        {
          "internalType": "bytes[]",
          "name": "signatures",
          "type": "bytes[]"
        }
      ],
      "name": "onCreatePlanDecryption",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "decryptedValue",
          "type": "uint256"
        },
        {
          "internalType": "bytes[]",
          "name": "signatures",
          "type": "bytes[]"
        }
      ],
      "name": "onWithdrawCallback",
      "outputs": [
        {
          "internalType": "bool",
          "name": "success",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "pairBatchCursor",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "planId",
          "type": "uint256"
        }
      ],
      "name": "pausePlan",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "plans",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "fromToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "toToken",
              "type": "address"
            }
          ],
          "internalType": "struct PlanTokens",
          "name": "tokens",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "startTime",
              "type": "uint64"
            },
            {
              "internalType": "euint64",
              "name": "interval",
              "type": "bytes32"
            },
            {
              "internalType": "euint64",
              "name": "lastExecutionTime",
              "type": "bytes32"
            },
            {
              "internalType": "euint64",
              "name": "totalIntervals",
              "type": "bytes32"
            },
            {
              "internalType": "euint64",
              "name": "executedIntervals",
              "type": "bytes32"
            }
          ],
          "internalType": "struct PlanTiming",
          "name": "timing",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "euint64",
              "name": "totalAmount",
              "type": "bytes32"
            },
            {
              "internalType": "euint64",
              "name": "remainingAmount",
              "type": "bytes32"
            },
            {
              "internalType": "euint64",
              "name": "amountPerInterval",
              "type": "bytes32"
            },
            {
              "internalType": "euint64",
              "name": "pendingOut",
              "type": "bytes32"
            }
          ],
          "internalType": "struct PlanAmounts",
          "name": "amounts",
          "type": "tuple"
        },
        {
          "internalType": "enum PlanStatus",
          "name": "status",
          "type": "uint8"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "requestId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "planId",
              "type": "uint256"
            }
          ],
          "internalType": "struct PlanMeta",
          "name": "meta",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "requestIdToPlanId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "requestIdToRecipient",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "requestIdToSender",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "requestProcessed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "planId",
          "type": "uint256"
        }
      ],
      "name": "resumePlan",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "router",
      "outputs": [
        {
          "internalType": "contract IUniswapV2Router02",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "who",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "allowed",
          "type": "bool"
        }
      ],
      "name": "setExecutor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "fromToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "toToken",
          "type": "address"
        }
      ],
      "name": "triggerBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "fromToken",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "fromName",
          "type": "string"
        },
        {
          "internalType": "uint8",
          "name": "fromDecimals",
          "type": "uint8"
        },
        {
          "internalType": "address",
          "name": "toToken",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "toName",
          "type": "string"
        },
        {
          "internalType": "uint8",
          "name": "toDecimals",
          "type": "uint8"
        },
        {
          "internalType": "bool",
          "name": "allowed",
          "type": "bool"
        }
      ],
      "name": "updateAllowedPair",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "planId",
          "type": "uint256"
        }
      ],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xf8c5989beca971fc434bf61faa9924317d34630b427b269ea674b5332596256e",
  "receipt": {
    "to": null,
    "from": "0x384Aa214be0B279cbf211e9b2C992d8633F77848",
    "contractAddress": "0x0765D126B0956975cF55dB84563b817936bfEc6f",
    "transactionIndex": 149,
    "gasUsed": "4413420",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000010000000000000000004000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000000000000000002000000400000000000000000000000000000000000000000000000000000000002000000000000008000000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x0f5e521c124b04f1af394616e2904295f6302b158d7dfa5db87bcb0a812a0154",
    "transactionHash": "0xf8c5989beca971fc434bf61faa9924317d34630b427b269ea674b5332596256e",
    "logs": [
      {
        "transactionIndex": 149,
        "blockNumber": 9058992,
        "transactionHash": "0xf8c5989beca971fc434bf61faa9924317d34630b427b269ea674b5332596256e",
        "address": "0x0765D126B0956975cF55dB84563b817936bfEc6f",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000384aa214be0b279cbf211e9b2c992d8633f77848"
        ],
        "data": "0x",
        "logIndex": 326,
        "blockHash": "0x0f5e521c124b04f1af394616e2904295f6302b158d7dfa5db87bcb0a812a0154"
      }
    ],
    "blockNumber": 9058992,
    "cumulativeGasUsed": "23866081",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
    "0xeE567Fe1712Faf6149d80dA1E6934E354124CfE3"
  ],
  "numDeployments": 57,
  "solcInputHash": "9ae296fc46d30784f5d854330b1d2d33",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"}],\"name\":\"BatchAlreadyExecuted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"CancelRequestAlreadyProcessed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20TransferFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"ERC20TransferReverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"ERC20TransferUnknownError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HandlesAlreadySavedForRequestID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provided\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expected\",\"type\":\"address\"}],\"name\":\"InvalidFromToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidKMSSignatures\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum PlanStatus\",\"name\":\"current\",\"type\":\"uint8\"},{\"internalType\":\"enum PlanStatus\",\"name\":\"expected\",\"type\":\"uint8\"}],\"name\":\"InvalidPlanStatus\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"InvalidWithdrawRequest\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"pairKey\",\"type\":\"bytes32\"}],\"name\":\"NoEligiblePlans\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandleFoundForRequestID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotPlanOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"PairAlreadyExists\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"}],\"name\":\"PairNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"PairNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"PlanNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"RefundReverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundUnknownError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"RequestAlreadyProcessed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"RequestAlreadyProcessing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"UnknownBatchRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnsupportedHandleType\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"}],\"name\":\"ZeroBatchInput\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"BatchExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"planCount\",\"type\":\"uint256\"}],\"name\":\"BatchTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestID\",\"type\":\"uint256\"}],\"name\":\"DecryptionFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"ExecutorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"PairUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"PlanCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"PlanCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"euint64\",\"name\":\"amount\",\"type\":\"bytes32\"}],\"name\":\"PlanDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"TransferFailed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BATCH_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_escrow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_refund\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"fromName\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"fromDecimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"toName\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"toDecimals\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"allowedPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"batchReqIdToBatchId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"batches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"euint64\",\"name\":\"totalInEnc\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"slotTime\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"cancelPlan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cancelReqIdToSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cancelRequestIdToPlanId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cancelRequestProcessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"externalEuint64\",\"name\":\"encInterval\",\"type\":\"bytes32\"},{\"internalType\":\"externalEuint64\",\"name\":\"encTotalAmount\",\"type\":\"bytes32\"},{\"internalType\":\"externalEuint64\",\"name\":\"encAmountPerInterval\",\"type\":\"bytes32\"},{\"internalType\":\"externalEuint64\",\"name\":\"encTotalIntervals\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"proofs\",\"type\":\"bytes\"}],\"name\":\"createPlan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"depositToPlan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"executors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPairs\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"fromName\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"fromDecimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"toName\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"toDecimals\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"internalType\":\"struct Pair[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextPlanId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decryptedValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"onBatchAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"decryptedAmount\",\"type\":\"uint64\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"onCancelPlanDecrypt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"decryptedAmount\",\"type\":\"uint64\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"onCreatePlanDecryption\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decryptedValue\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"name\":\"onWithdrawCallback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pairBatchCursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"pausePlan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plans\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"}],\"internalType\":\"struct PlanTokens\",\"name\":\"tokens\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"euint64\",\"name\":\"interval\",\"type\":\"bytes32\"},{\"internalType\":\"euint64\",\"name\":\"lastExecutionTime\",\"type\":\"bytes32\"},{\"internalType\":\"euint64\",\"name\":\"totalIntervals\",\"type\":\"bytes32\"},{\"internalType\":\"euint64\",\"name\":\"executedIntervals\",\"type\":\"bytes32\"}],\"internalType\":\"struct PlanTiming\",\"name\":\"timing\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"euint64\",\"name\":\"totalAmount\",\"type\":\"bytes32\"},{\"internalType\":\"euint64\",\"name\":\"remainingAmount\",\"type\":\"bytes32\"},{\"internalType\":\"euint64\",\"name\":\"amountPerInterval\",\"type\":\"bytes32\"},{\"internalType\":\"euint64\",\"name\":\"pendingOut\",\"type\":\"bytes32\"}],\"internalType\":\"struct PlanAmounts\",\"name\":\"amounts\",\"type\":\"tuple\"},{\"internalType\":\"enum PlanStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"internalType\":\"struct PlanMeta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requestIdToPlanId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requestIdToRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requestIdToSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requestProcessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"resumePlan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"}],\"name\":\"triggerBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"fromName\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"fromDecimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"toName\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"toDecimals\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"updateAllowedPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"planId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}],\"ReentrancyGuardReentrantCall()\":[{\"details\":\"Unauthorized reentrant call.\"}]},\"kind\":\"dev\",\"methods\":{\"_escrow(address,uint256)\":{\"details\":\"Externalized transfer to keep a clean try/catch surface.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"errors\":{\"HandlesAlreadySavedForRequestID()\":[{\"notice\":\"Returned if some handles were already saved for corresponding ID.\"}],\"InvalidKMSSignatures()\":[{\"notice\":\"Returned if the returned KMS signatures are not valid.\"}],\"NoHandleFoundForRequestID()\":[{\"notice\":\"Returned if there was not handle found for the requested ID.\"}],\"UnsupportedHandleType()\":[{\"notice\":\"Returned if the requested handle to be decrypted is not of a supported type.\"}]},\"events\":{\"DecryptionFulfilled(uint256)\":{\"notice\":\"This event is emitted when requested decryption has been fulfilled.\"}},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ConfidentialDCABatch.sol\":\"ConfidentialDCABatch\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"@fhevm/solidity/config/ZamaConfig.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {SepoliaZamaOracleAddress} from \\\"@zama-fhe/oracle-solidity/address/ZamaOracleAddress.sol\\\";\\nimport {FHE} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\nimport {FHEVMConfigStruct} from \\\"@fhevm/solidity/lib/Impl.sol\\\";\\n\\n/**\\n * @title   ZamaConfig.\\n * @notice  This library returns the FHEVM config for different networks\\n *          with the contract addresses for (1) ACL, (2) FHEVMExecutor, (3) KMSVerifier, (4) InputVerifier\\n *          which are deployed & maintained by Zama. It also returns the address of the decryption oracle.\\n */\\nlibrary ZamaConfig {\\n    function getSepoliaConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        return\\n            FHEVMConfigStruct({\\n                ACLAddress: 0x687820221192C5B662b25367F70076A37bc79b6c,\\n                FHEVMExecutorAddress: 0x848B0066793BcC60346Da1F49049357399B8D595,\\n                KMSVerifierAddress: 0x1364cBBf2cDF5032C47d8226a6f6FBD2AFCDacAC,\\n                InputVerifierAddress: 0xbc91f3daD1A5F19F8390c400196e58073B6a0BC4\\n            });\\n    }\\n\\n    function getSepoliaOracleAddress() internal pure returns (address) {\\n        return SepoliaZamaOracleAddress;\\n    }\\n\\n    function getEthereumConfig() internal pure returns (FHEVMConfigStruct memory) {\\n        /// @note The addresses below are placeholders and should be replaced with actual addresses\\n        /// once deployed on the Ethereum mainnet.\\n        return\\n            FHEVMConfigStruct({\\n                ACLAddress: address(0),\\n                FHEVMExecutorAddress: address(0),\\n                KMSVerifierAddress: address(0),\\n                InputVerifierAddress: address(0)\\n            });\\n    }\\n\\n    function getEthereumOracleAddress() internal pure returns (address) {\\n        /// @note Placeholder, should be replaced with actual address once deployed.\\n        return address(0);\\n    }\\n}\\n\\n/**\\n * @title   SepoliaConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Sepolia network (chainId = 11155111).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract SepoliaConfig {\\n    constructor() {\\n        FHE.setCoprocessor(ZamaConfig.getSepoliaConfig());\\n        FHE.setDecryptionOracle(ZamaConfig.getSepoliaOracleAddress());\\n    }\\n}\\n\\n/**\\n * @title   EthereumConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Ethereum (mainnet) network (chainId = 1).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract EthereumConfig {\\n    constructor() {\\n        FHE.setCoprocessor(ZamaConfig.getEthereumConfig());\\n        FHE.setDecryptionOracle(ZamaConfig.getEthereumOracleAddress());\\n    }\\n}\\n\",\"keccak256\":\"0xccc1e461a5283c9e68d645d1967fd661e2f6a62ed782812a32552c7d7a3d28a3\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhevm/solidity/lib/FHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./Impl.sol\\\";\\nimport {FheType} from \\\"./FheType.sol\\\";\\n\\nimport \\\"encrypted-types/EncryptedTypes.sol\\\";\\n\\n/**\\n * @title IKMSVerifier\\n * @notice This interface contains the only function required from KMSVerifier.\\n */\\ninterface IKMSVerifier {\\n    function verifyDecryptionEIP712KMSSignatures(\\n        bytes32[] memory handlesList,\\n        bytes memory decryptedResult,\\n        bytes[] memory signatures\\n    ) external returns (bool);\\n}\\n\\n/**\\n * @title IDecryptionOracle\\n * @notice This interface contains the only function required from DecryptionOracle.\\n */\\ninterface IDecryptionOracle {\\n    function requestDecryption(\\n        uint256 requestID,\\n        bytes32[] calldata ctsHandles,\\n        bytes4 callbackSelector\\n    ) external payable;\\n}\\n\\n/**\\n * @title   FHE\\n * @notice  This library is the interaction point for all smart contract developers\\n *          that interact with the FHEVM protocol.\\n */\\nlibrary FHE {\\n    /// @notice Returned if some handles were already saved for corresponding ID.\\n    error HandlesAlreadySavedForRequestID();\\n\\n    /// @notice Returned if there was not handle found for the requested ID.\\n    error NoHandleFoundForRequestID();\\n\\n    /// @notice Returned if the returned KMS signatures are not valid.\\n    error InvalidKMSSignatures();\\n\\n    /// @notice Returned if the requested handle to be decrypted is not of a supported type.\\n    error UnsupportedHandleType();\\n\\n    /// @notice This event is emitted when requested decryption has been fulfilled.\\n    event DecryptionFulfilled(uint256 indexed requestID);\\n\\n    /**\\n     * @notice            Sets the coprocessor addresses.\\n     * @param fhevmConfig FHEVM config struct that contains contract addresses.\\n     */\\n    function setCoprocessor(FHEVMConfigStruct memory fhevmConfig) internal {\\n        Impl.setCoprocessor(fhevmConfig);\\n    }\\n\\n    /**\\n     * @notice                  Sets the decryption oracle address.\\n     * @param decryptionOracle  The decryption oracle address.\\n     */\\n    function setDecryptionOracle(address decryptionOracle) internal {\\n        Impl.setDecryptionOracle(decryptionOracle);\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint64 v) internal pure returns (bool) {\\n        return euint64.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint128 v) internal pure returns (bool) {\\n        return euint128.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(eaddress v) internal pure returns (bool) {\\n        return eaddress.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint256 v) internal pure returns (bool) {\\n        return euint256.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Evaluates and(ebool a, ebool b) and returns the result.\\n     */\\n    function and(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(ebool a, ebool b) and returns the result.\\n     */\\n    function or(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(ebool a, ebool b) and returns the result.\\n     */\\n    function xor(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(ebool a, ebool b) and returns the result.\\n     */\\n    function eq(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(ebool a, ebool b) and returns the result.\\n     */\\n    function ne(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(eaddress a, eaddress b) and returns the result.\\n     */\\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(eaddress a, eaddress b) and returns the result.\\n     */\\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(ebool a, bool b) and returns the result.\\n     */\\n    function and(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(bool a, ebool b) and returns the result.\\n     */\\n    function and(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.and(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(ebool a, bool b) and returns the result.\\n     */\\n    function or(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(bool a, ebool b) and returns the result.\\n     */\\n    function or(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.or(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(ebool a, bool b) and returns the result.\\n     */\\n    function xor(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(bool a, ebool b) and returns the result.\\n     */\\n    function xor(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(ebool a, bool b) and returns the result.\\n     */\\n    function eq(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(bool a, ebool b) and returns the result.\\n     */\\n    function eq(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(ebool a, bool b) and returns the result.\\n     */\\n    function ne(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(bool a, ebool b) and returns the result.\\n     */\\n    function ne(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, uint8 b) and returns the result.\\n     */\\n    function add(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint8 a, euint8 b) and returns the result.\\n     */\\n    function add(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, uint8 b) and returns the result.\\n     */\\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint8 a, euint8 b) and returns the result.\\n     */\\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\\n        euint8 aEnc = asEuint8(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, uint8 b) and returns the result.\\n     */\\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint8 a, euint8 b) and returns the result.\\n     */\\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint8 a, uint8 b) and returns the result.\\n     */\\n    function div(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.div(euint8.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint8 a, uint8 b) and returns the result.\\n     */\\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, uint8 b) and returns the result.\\n     */\\n    function and(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint8 a, euint8 b) and returns the result.\\n     */\\n    function and(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, uint8 b) and returns the result.\\n     */\\n    function or(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint8 a, euint8 b) and returns the result.\\n     */\\n    function or(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, uint8 b) and returns the result.\\n     */\\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint8 a, euint8 b) and returns the result.\\n     */\\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, uint8 b) and returns the result.\\n     */\\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint8 a, euint8 b) and returns the result.\\n     */\\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, uint8 b) and returns the result.\\n     */\\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint8 a, euint8 b) and returns the result.\\n     */\\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, uint8 b) and returns the result.\\n     */\\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint8 a, euint8 b) and returns the result.\\n     */\\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, uint8 b) and returns the result.\\n     */\\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint8 a, euint8 b) and returns the result.\\n     */\\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, uint8 b) and returns the result.\\n     */\\n    function le(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint8 a, euint8 b) and returns the result.\\n     */\\n    function le(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, uint8 b) and returns the result.\\n     */\\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint8 a, euint8 b) and returns the result.\\n     */\\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, uint8 b) and returns the result.\\n     */\\n    function min(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint8 a, euint8 b) and returns the result.\\n     */\\n    function min(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, uint8 b) and returns the result.\\n     */\\n    function max(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint8 a, euint8 b) and returns the result.\\n     */\\n    function max(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, uint16 b) and returns the result.\\n     */\\n    function add(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint16 a, euint16 b) and returns the result.\\n     */\\n    function add(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, uint16 b) and returns the result.\\n     */\\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint16 a, euint16 b) and returns the result.\\n     */\\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\\n        euint16 aEnc = asEuint16(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, uint16 b) and returns the result.\\n     */\\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint16 a, euint16 b) and returns the result.\\n     */\\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint16 a, uint16 b) and returns the result.\\n     */\\n    function div(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.div(euint16.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint16 a, uint16 b) and returns the result.\\n     */\\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, uint16 b) and returns the result.\\n     */\\n    function and(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint16 a, euint16 b) and returns the result.\\n     */\\n    function and(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, uint16 b) and returns the result.\\n     */\\n    function or(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint16 a, euint16 b) and returns the result.\\n     */\\n    function or(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, uint16 b) and returns the result.\\n     */\\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint16 a, euint16 b) and returns the result.\\n     */\\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, uint16 b) and returns the result.\\n     */\\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint16 a, euint16 b) and returns the result.\\n     */\\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, uint16 b) and returns the result.\\n     */\\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint16 a, euint16 b) and returns the result.\\n     */\\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, uint16 b) and returns the result.\\n     */\\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint16 a, euint16 b) and returns the result.\\n     */\\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, uint16 b) and returns the result.\\n     */\\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint16 a, euint16 b) and returns the result.\\n     */\\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, uint16 b) and returns the result.\\n     */\\n    function le(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint16 a, euint16 b) and returns the result.\\n     */\\n    function le(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, uint16 b) and returns the result.\\n     */\\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint16 a, euint16 b) and returns the result.\\n     */\\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, uint16 b) and returns the result.\\n     */\\n    function min(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint16 a, euint16 b) and returns the result.\\n     */\\n    function min(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, uint16 b) and returns the result.\\n     */\\n    function max(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint16 a, euint16 b) and returns the result.\\n     */\\n    function max(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, uint32 b) and returns the result.\\n     */\\n    function add(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint32 a, euint32 b) and returns the result.\\n     */\\n    function add(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, uint32 b) and returns the result.\\n     */\\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint32 a, euint32 b) and returns the result.\\n     */\\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\\n        euint32 aEnc = asEuint32(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, uint32 b) and returns the result.\\n     */\\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint32 a, euint32 b) and returns the result.\\n     */\\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint32 a, uint32 b) and returns the result.\\n     */\\n    function div(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.div(euint32.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint32 a, uint32 b) and returns the result.\\n     */\\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, uint32 b) and returns the result.\\n     */\\n    function and(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint32 a, euint32 b) and returns the result.\\n     */\\n    function and(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, uint32 b) and returns the result.\\n     */\\n    function or(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint32 a, euint32 b) and returns the result.\\n     */\\n    function or(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, uint32 b) and returns the result.\\n     */\\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint32 a, euint32 b) and returns the result.\\n     */\\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, uint32 b) and returns the result.\\n     */\\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint32 a, euint32 b) and returns the result.\\n     */\\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, uint32 b) and returns the result.\\n     */\\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint32 a, euint32 b) and returns the result.\\n     */\\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, uint32 b) and returns the result.\\n     */\\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint32 a, euint32 b) and returns the result.\\n     */\\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, uint32 b) and returns the result.\\n     */\\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint32 a, euint32 b) and returns the result.\\n     */\\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, uint32 b) and returns the result.\\n     */\\n    function le(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint32 a, euint32 b) and returns the result.\\n     */\\n    function le(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, uint32 b) and returns the result.\\n     */\\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint32 a, euint32 b) and returns the result.\\n     */\\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, uint32 b) and returns the result.\\n     */\\n    function min(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint32 a, euint32 b) and returns the result.\\n     */\\n    function min(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, uint32 b) and returns the result.\\n     */\\n    function max(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint32 a, euint32 b) and returns the result.\\n     */\\n    function max(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, uint64 b) and returns the result.\\n     */\\n    function add(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint64 a, euint64 b) and returns the result.\\n     */\\n    function add(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, uint64 b) and returns the result.\\n     */\\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint64 a, euint64 b) and returns the result.\\n     */\\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\\n        euint64 aEnc = asEuint64(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, uint64 b) and returns the result.\\n     */\\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint64 a, euint64 b) and returns the result.\\n     */\\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint64 a, uint64 b) and returns the result.\\n     */\\n    function div(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.div(euint64.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint64 a, uint64 b) and returns the result.\\n     */\\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, uint64 b) and returns the result.\\n     */\\n    function and(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint64 a, euint64 b) and returns the result.\\n     */\\n    function and(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, uint64 b) and returns the result.\\n     */\\n    function or(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint64 a, euint64 b) and returns the result.\\n     */\\n    function or(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, uint64 b) and returns the result.\\n     */\\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint64 a, euint64 b) and returns the result.\\n     */\\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, uint64 b) and returns the result.\\n     */\\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint64 a, euint64 b) and returns the result.\\n     */\\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, uint64 b) and returns the result.\\n     */\\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint64 a, euint64 b) and returns the result.\\n     */\\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, uint64 b) and returns the result.\\n     */\\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint64 a, euint64 b) and returns the result.\\n     */\\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, uint64 b) and returns the result.\\n     */\\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint64 a, euint64 b) and returns the result.\\n     */\\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, uint64 b) and returns the result.\\n     */\\n    function le(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint64 a, euint64 b) and returns the result.\\n     */\\n    function le(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, uint64 b) and returns the result.\\n     */\\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint64 a, euint64 b) and returns the result.\\n     */\\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, uint64 b) and returns the result.\\n     */\\n    function min(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint64 a, euint64 b) and returns the result.\\n     */\\n    function min(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, uint64 b) and returns the result.\\n     */\\n    function max(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint64 a, euint64 b) and returns the result.\\n     */\\n    function max(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, uint128 b) and returns the result.\\n     */\\n    function add(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint128 a, euint128 b) and returns the result.\\n     */\\n    function add(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, uint128 b) and returns the result.\\n     */\\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint128 a, euint128 b) and returns the result.\\n     */\\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\\n        euint128 aEnc = asEuint128(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, uint128 b) and returns the result.\\n     */\\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint128 a, euint128 b) and returns the result.\\n     */\\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint128 a, uint128 b) and returns the result.\\n     */\\n    function div(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.div(euint128.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint128 a, uint128 b) and returns the result.\\n     */\\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, uint128 b) and returns the result.\\n     */\\n    function and(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint128 a, euint128 b) and returns the result.\\n     */\\n    function and(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, uint128 b) and returns the result.\\n     */\\n    function or(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint128 a, euint128 b) and returns the result.\\n     */\\n    function or(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, uint128 b) and returns the result.\\n     */\\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint128 a, euint128 b) and returns the result.\\n     */\\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, uint128 b) and returns the result.\\n     */\\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint128 a, euint128 b) and returns the result.\\n     */\\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, uint128 b) and returns the result.\\n     */\\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint128 a, euint128 b) and returns the result.\\n     */\\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, uint128 b) and returns the result.\\n     */\\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint128 a, euint128 b) and returns the result.\\n     */\\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, uint128 b) and returns the result.\\n     */\\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint128 a, euint128 b) and returns the result.\\n     */\\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, uint128 b) and returns the result.\\n     */\\n    function le(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint128 a, euint128 b) and returns the result.\\n     */\\n    function le(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, uint128 b) and returns the result.\\n     */\\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint128 a, euint128 b) and returns the result.\\n     */\\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, uint128 b) and returns the result.\\n     */\\n    function min(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint128 a, euint128 b) and returns the result.\\n     */\\n    function min(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, uint128 b) and returns the result.\\n     */\\n    function max(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint128 a, euint128 b) and returns the result.\\n     */\\n    function max(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(eaddress a, address b) and returns the result.\\n     */\\n    function eq(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bytes32(uint256(uint160(b))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(address a, eaddress b) and returns the result.\\n     */\\n    function eq(address a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(b), bytes32(uint256(uint160(a))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(eaddress a, address b) and returns the result.\\n     */\\n    function ne(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bytes32(uint256(uint160(b))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(address a, eaddress b) and returns the result.\\n     */\\n    function ne(address a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(b), bytes32(uint256(uint160(a))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, uint256 b) and returns the result.\\n     */\\n    function and(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint256 a, euint256 b) and returns the result.\\n     */\\n    function and(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, uint256 b) and returns the result.\\n     */\\n    function or(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint256 a, euint256 b) and returns the result.\\n     */\\n    function or(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, uint256 b) and returns the result.\\n     */\\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint256 a, euint256 b) and returns the result.\\n     */\\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, uint256 b) and returns the result.\\n     */\\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint256 a, euint256 b) and returns the result.\\n     */\\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, uint256 b) and returns the result.\\n     */\\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint256 a, euint256 b) and returns the result.\\n     */\\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint8 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint8 a, uint8) and returns the result.\\n     */\\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint8 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint8 a, uint8) and returns the result.\\n     */\\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint8 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint8 a, uint8) and returns the result.\\n     */\\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint8 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint8 a, uint8) and returns the result.\\n     */\\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint16 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint16 a, uint8) and returns the result.\\n     */\\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint16 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint16 a, uint8) and returns the result.\\n     */\\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint16 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint16 a, uint8) and returns the result.\\n     */\\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint16 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint16 a, uint8) and returns the result.\\n     */\\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint32 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint32 a, uint8) and returns the result.\\n     */\\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint32 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint32 a, uint8) and returns the result.\\n     */\\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint32 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint32 a, uint8) and returns the result.\\n     */\\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint32 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint32 a, uint8) and returns the result.\\n     */\\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint64 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint64 a, uint8) and returns the result.\\n     */\\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint64 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint64 a, uint8) and returns the result.\\n     */\\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint64 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint64 a, uint8) and returns the result.\\n     */\\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint64 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint64 a, uint8) and returns the result.\\n     */\\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint128 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint128 a, uint8) and returns the result.\\n     */\\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint128 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint128 a, uint8) and returns the result.\\n     */\\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint128 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint128 a, uint8) and returns the result.\\n     */\\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint128 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint128 a, uint8) and returns the result.\\n     */\\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint256 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint256 a, uint8) and returns the result.\\n     */\\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint256 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint256 a, uint8) and returns the result.\\n     */\\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint256 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint256 a, uint8) and returns the result.\\n     */\\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint256 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint256 a, uint8) and returns the result.\\n     */\\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\\n    }\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint8'.\\n     */\\n    function asEuint8(euint16 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint8'.\\n     */\\n    function asEuint8(euint32 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint8'.\\n     */\\n    function asEuint8(euint64 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint8'.\\n     */\\n    function asEuint8(euint128 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint8'.\\n     */\\n    function asEuint8(euint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint8'.\\n     */\\n    function asEuint8(ebool b) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'ebool'.\\n     */\\n    function asEbool(euint8 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint16'.\\n     */\\n    function asEuint16(euint8 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint16'.\\n     */\\n    function asEuint16(euint32 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint16'.\\n     */\\n    function asEuint16(euint64 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint16'.\\n     */\\n    function asEuint16(euint128 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint16'.\\n     */\\n    function asEuint16(euint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint16'.\\n     */\\n    function asEuint16(ebool b) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'ebool'.\\n     */\\n    function asEbool(euint16 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint32'.\\n     */\\n    function asEuint32(euint8 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint32'.\\n     */\\n    function asEuint32(euint16 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint32'.\\n     */\\n    function asEuint32(euint64 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint32'.\\n     */\\n    function asEuint32(euint128 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint32'.\\n     */\\n    function asEuint32(euint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint32'.\\n     */\\n    function asEuint32(ebool b) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'ebool'.\\n     */\\n    function asEbool(euint32 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint64'.\\n     */\\n    function asEuint64(euint8 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint64'.\\n     */\\n    function asEuint64(euint16 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint64'.\\n     */\\n    function asEuint64(euint32 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint64'.\\n     */\\n    function asEuint64(euint128 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint64'.\\n     */\\n    function asEuint64(euint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint64'.\\n     */\\n    function asEuint64(ebool b) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'ebool'.\\n     */\\n    function asEbool(euint64 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint128'.\\n     */\\n    function asEuint128(euint8 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint128'.\\n     */\\n    function asEuint128(euint16 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint128'.\\n     */\\n    function asEuint128(euint32 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint128'.\\n     */\\n    function asEuint128(euint64 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint128'.\\n     */\\n    function asEuint128(euint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint128'.\\n     */\\n    function asEuint128(ebool b) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'ebool'.\\n     */\\n    function asEbool(euint128 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint256'.\\n     */\\n    function asEuint256(euint8 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint256'.\\n     */\\n    function asEuint256(euint16 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint256'.\\n     */\\n    function asEuint256(euint32 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint256'.\\n     */\\n    function asEuint256(euint64 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint256'.\\n     */\\n    function asEuint256(euint128 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint256'.\\n     */\\n    function asEuint256(ebool b) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'ebool'.\\n     */\\n    function asEbool(euint256 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Evaluates not(ebool value) and returns the result.\\n     */\\n    function not(ebool value) internal returns (ebool) {\\n        return ebool.wrap(Impl.not(ebool.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint8 value) and returns the result.\\n     */\\n    function neg(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint8 value) and returns the result.\\n     */\\n    function not(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint16 value) and returns the result.\\n     */\\n    function neg(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint16 value) and returns the result.\\n     */\\n    function not(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint32 value) and returns the result.\\n     */\\n    function neg(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint32 value) and returns the result.\\n     */\\n    function not(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint64 value) and returns the result.\\n     */\\n    function neg(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint64 value) and returns the result.\\n     */\\n    function not(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint128 value) and returns the result.\\n     */\\n    function neg(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint128 value) and returns the result.\\n     */\\n    function not(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint256 value) and returns the result.\\n     */\\n    function neg(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint256 value) and returns the result.\\n     */\\n    function not(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted ebool integer.\\n     */\\n    function fromExternal(externalEbool inputHandle, bytes memory inputProof) internal returns (ebool) {\\n        return ebool.wrap(Impl.verify(externalEbool.unwrap(inputHandle), inputProof, FheType.Bool));\\n    }\\n\\n    /**\\n     * @dev Converts a plaintext boolean to an encrypted boolean.\\n     */\\n    function asEbool(bool value) internal returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value ? 1 : 0, FheType.Bool));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\\n     */\\n    function fromExternal(externalEuint8 inputHandle, bytes memory inputProof) internal returns (euint8) {\\n        return euint8.wrap(Impl.verify(externalEuint8.unwrap(inputHandle), inputProof, FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint8 integer.\\n     */\\n    function asEuint8(uint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\\n     */\\n    function fromExternal(externalEuint16 inputHandle, bytes memory inputProof) internal returns (euint16) {\\n        return euint16.wrap(Impl.verify(externalEuint16.unwrap(inputHandle), inputProof, FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint16 integer.\\n     */\\n    function asEuint16(uint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\\n     */\\n    function fromExternal(externalEuint32 inputHandle, bytes memory inputProof) internal returns (euint32) {\\n        return euint32.wrap(Impl.verify(externalEuint32.unwrap(inputHandle), inputProof, FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint32 integer.\\n     */\\n    function asEuint32(uint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\\n     */\\n    function fromExternal(externalEuint64 inputHandle, bytes memory inputProof) internal returns (euint64) {\\n        return euint64.wrap(Impl.verify(externalEuint64.unwrap(inputHandle), inputProof, FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint64 integer.\\n     */\\n    function asEuint64(uint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\\n     */\\n    function fromExternal(externalEuint128 inputHandle, bytes memory inputProof) internal returns (euint128) {\\n        return euint128.wrap(Impl.verify(externalEuint128.unwrap(inputHandle), inputProof, FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint128 integer.\\n     */\\n    function asEuint128(uint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted eaddress integer.\\n     */\\n    function fromExternal(externalEaddress inputHandle, bytes memory inputProof) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.verify(externalEaddress.unwrap(inputHandle), inputProof, FheType.Uint160));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted eaddress integer.\\n     */\\n    function asEaddress(address value) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(uint256(uint160(value)), FheType.Uint160));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\\n     */\\n    function fromExternal(externalEuint256 inputHandle, bytes memory inputProof) internal returns (euint256) {\\n        return euint256.wrap(Impl.verify(externalEuint256.unwrap(inputHandle), inputProof, FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint256 integer.\\n     */\\n    function asEuint256(uint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEbool() internal returns (ebool) {\\n        return ebool.wrap(Impl.rand(FheType.Bool));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint8() internal returns (euint8) {\\n        return euint8.wrap(Impl.rand(FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\\n        return euint8.wrap(Impl.randBounded(upperBound, FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint16() internal returns (euint16) {\\n        return euint16.wrap(Impl.rand(FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\\n        return euint16.wrap(Impl.randBounded(upperBound, FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint32() internal returns (euint32) {\\n        return euint32.wrap(Impl.rand(FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\\n        return euint32.wrap(Impl.randBounded(upperBound, FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint64() internal returns (euint64) {\\n        return euint64.wrap(Impl.rand(FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\\n        return euint64.wrap(Impl.randBounded(upperBound, FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint128() internal returns (euint128) {\\n        return euint128.wrap(Impl.rand(FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\\n        return euint128.wrap(Impl.randBounded(upperBound, FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint256() internal returns (euint256) {\\n        return euint256.wrap(Impl.rand(FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\\n        return euint256.wrap(Impl.randBounded(upperBound, FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev This function cleans the transient storage for the ACL (accounts) and the InputVerifier\\n     *      (input proofs).\\n     *      This could be useful for integration with Account Abstraction when bundling several\\n     *      UserOps calling the FHEVMExecutor.\\n     */\\n    function cleanTransientStorage() internal {\\n        Impl.cleanTransientStorageACL();\\n        Impl.cleanTransientStorageInputVerifier();\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(ebool value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(ebool value) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(ebool value, address account) internal returns (ebool) {\\n        Impl.allow(ebool.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(ebool value) internal returns (ebool) {\\n        Impl.allow(ebool.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(ebool value, address account) internal returns (ebool) {\\n        Impl.allowTransient(ebool.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(ebool value) internal returns (ebool) {\\n        Impl.makePubliclyDecryptable(ebool.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(ebool value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(ebool.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint8 value, address account) internal returns (euint8) {\\n        Impl.allow(euint8.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint8 value) internal returns (euint8) {\\n        Impl.allow(euint8.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint8 value, address account) internal returns (euint8) {\\n        Impl.allowTransient(euint8.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint8 value) internal returns (euint8) {\\n        Impl.makePubliclyDecryptable(euint8.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint8 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint8.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint16 value, address account) internal returns (euint16) {\\n        Impl.allow(euint16.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint16 value) internal returns (euint16) {\\n        Impl.allow(euint16.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint16 value, address account) internal returns (euint16) {\\n        Impl.allowTransient(euint16.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint16 value) internal returns (euint16) {\\n        Impl.makePubliclyDecryptable(euint16.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint16 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint16.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint32 value, address account) internal returns (euint32) {\\n        Impl.allow(euint32.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint32 value) internal returns (euint32) {\\n        Impl.allow(euint32.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint32 value, address account) internal returns (euint32) {\\n        Impl.allowTransient(euint32.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint32 value) internal returns (euint32) {\\n        Impl.makePubliclyDecryptable(euint32.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint32 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint32.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint64 value, address account) internal returns (euint64) {\\n        Impl.allow(euint64.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint64 value) internal returns (euint64) {\\n        Impl.allow(euint64.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint64 value, address account) internal returns (euint64) {\\n        Impl.allowTransient(euint64.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint64 value) internal returns (euint64) {\\n        Impl.makePubliclyDecryptable(euint64.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint64 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint64.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint128 value, address account) internal returns (euint128) {\\n        Impl.allow(euint128.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint128 value) internal returns (euint128) {\\n        Impl.allow(euint128.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint128 value, address account) internal returns (euint128) {\\n        Impl.allowTransient(euint128.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint128 value) internal returns (euint128) {\\n        Impl.makePubliclyDecryptable(euint128.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint128 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint128.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(eaddress value, address account) internal returns (eaddress) {\\n        Impl.allow(eaddress.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(eaddress value) internal returns (eaddress) {\\n        Impl.allow(eaddress.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(eaddress value, address account) internal returns (eaddress) {\\n        Impl.allowTransient(eaddress.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(eaddress value) internal returns (eaddress) {\\n        Impl.makePubliclyDecryptable(eaddress.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(eaddress value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(eaddress.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint256 value, address account) internal returns (euint256) {\\n        Impl.allow(euint256.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint256 value) internal returns (euint256) {\\n        Impl.allow(euint256.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint256 value, address account) internal returns (euint256) {\\n        Impl.allowTransient(euint256.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint256 value) internal returns (euint256) {\\n        Impl.makePubliclyDecryptable(euint256.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint256 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint256.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Recovers the stored array of handles corresponding to requestID.\\n     */\\n    function loadRequestedHandles(uint256 requestID) internal view returns (bytes32[] memory) {\\n        DecryptionRequestsStruct storage $ = Impl.getDecryptionRequests();\\n        if ($.requestedHandles[requestID].length == 0) {\\n            revert NoHandleFoundForRequestID();\\n        }\\n        return $.requestedHandles[requestID];\\n    }\\n\\n    /**\\n     * @dev     Calls the DecryptionOracle contract to request the decryption of a list of handles.\\n     * @notice  Also does the needed call to ACL::allowForDecryption with requested handles.\\n     */\\n    function requestDecryption(\\n        bytes32[] memory ctsHandles,\\n        bytes4 callbackSelector\\n    ) internal returns (uint256 requestID) {\\n        requestID = requestDecryption(ctsHandles, callbackSelector, 0);\\n    }\\n\\n    /**\\n     * @dev     Calls the DecryptionOracle contract to request the decryption of a list of handles, with a custom msgValue.\\n     * @notice  Also does the needed call to ACL::allowForDecryption with requested handles.\\n     */\\n    function requestDecryption(\\n        bytes32[] memory ctsHandles,\\n        bytes4 callbackSelector,\\n        uint256 msgValue\\n    ) internal returns (uint256 requestID) {\\n        DecryptionRequestsStruct storage $ = Impl.getDecryptionRequests();\\n        requestID = $.counterRequest;\\n        FHEVMConfigStruct storage $$ = Impl.getFHEVMConfig();\\n        IACL($$.ACLAddress).allowForDecryption(ctsHandles);\\n        IDecryptionOracle($.DecryptionOracleAddress).requestDecryption{value: msgValue}(\\n            requestID,\\n            ctsHandles,\\n            callbackSelector\\n        );\\n        saveRequestedHandles(requestID, ctsHandles);\\n        $.counterRequest++;\\n    }\\n\\n    /**\\n     * @dev     MUST be called inside the callback function the dApp contract to verify the signatures,\\n     * @dev     otherwise fake decryption results could be submitted.\\n     * @notice  Warning: MUST be called directly in the callback function called by the relayer.\\n     */\\n    function checkSignatures(uint256 requestID, bytes[] memory signatures) internal {\\n        bytes32[] memory handlesList = loadRequestedHandles(requestID);\\n        bool isVerified = verifySignatures(handlesList, signatures);\\n        if (!isVerified) {\\n            revert InvalidKMSSignatures();\\n        }\\n        emit DecryptionFulfilled(requestID);\\n    }\\n\\n    /**\\n     * @dev Private low-level function used to link in storage an array of handles to its associated requestID.\\n     */\\n    function saveRequestedHandles(uint256 requestID, bytes32[] memory handlesList) private {\\n        DecryptionRequestsStruct storage $ = Impl.getDecryptionRequests();\\n        if ($.requestedHandles[requestID].length != 0) {\\n            revert HandlesAlreadySavedForRequestID();\\n        }\\n        $.requestedHandles[requestID] = handlesList;\\n    }\\n\\n    /**\\n     * @dev Private low-level function used to extract the decryptedResult bytes array and verify the KMS signatures.\\n     * @notice  Warning: MUST be called directly in the callback function called by the relayer.\\n     */\\n    function verifySignatures(bytes32[] memory handlesList, bytes[] memory signatures) private returns (bool) {\\n        uint256 start = 4 + 32; // start position after skipping the selector (4 bytes) and the first argument (index, 32 bytes)\\n        uint256 length = getSignedDataLength(handlesList);\\n        bytes memory decryptedResult = new bytes(length);\\n        assembly {\\n            calldatacopy(add(decryptedResult, 0x20), start, length) // Copy the relevant part of calldata to decryptedResult memory\\n        }\\n        FHEVMConfigStruct storage $ = Impl.getFHEVMConfig();\\n        return\\n            IKMSVerifier($.KMSVerifierAddress).verifyDecryptionEIP712KMSSignatures(\\n                handlesList,\\n                decryptedResult,\\n                signatures\\n            );\\n    }\\n\\n    /**\\n     * @dev Private low-level function used to compute the length of the decryptedResult bytes array.\\n     */\\n    function getSignedDataLength(bytes32[] memory handlesList) private pure returns (uint256) {\\n        uint256 handlesListlen = handlesList.length;\\n        uint256 signedDataLength;\\n        for (uint256 i = 0; i < handlesListlen; i++) {\\n            FheType typeCt = FheType(uint8(handlesList[i][30]));\\n            if (uint8(typeCt) < 9) {\\n                signedDataLength += 32;\\n            } else {\\n                revert UnsupportedHandleType();\\n            }\\n        }\\n        signedDataLength += 32; // add offset of signatures\\n        return signedDataLength;\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(ebool value) internal pure returns (bytes32 ct) {\\n        ct = ebool.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint8 value) internal pure returns (bytes32 ct) {\\n        ct = euint8.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint16 value) internal pure returns (bytes32 ct) {\\n        ct = euint16.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint32 value) internal pure returns (bytes32 ct) {\\n        ct = euint32.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint64 value) internal pure returns (bytes32 ct) {\\n        ct = euint64.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint128 value) internal pure returns (bytes32 ct) {\\n        ct = euint128.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(eaddress value) internal pure returns (bytes32 ct) {\\n        ct = eaddress.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint256 value) internal pure returns (bytes32 ct) {\\n        ct = euint256.unwrap(value);\\n    }\\n}\\n\",\"keccak256\":\"0xb2c27424f0fb955b4d55ba9584fcbb0f86be91a1136c548062b9b52148fc0724\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhevm/solidity/lib/FheType.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nenum FheType {\\n    Bool,\\n    Uint4,\\n    Uint8,\\n    Uint16,\\n    Uint32,\\n    Uint64,\\n    Uint128,\\n    Uint160,\\n    Uint256,\\n    Uint512,\\n    Uint1024,\\n    Uint2048,\\n    Uint2,\\n    Uint6,\\n    Uint10,\\n    Uint12,\\n    Uint14,\\n    Int2,\\n    Int4,\\n    Int6,\\n    Int8,\\n    Int10,\\n    Int12,\\n    Int14,\\n    Int16,\\n    Int32,\\n    Int64,\\n    Int128,\\n    Int160,\\n    Int256,\\n    AsciiString,\\n    Int512,\\n    Int1024,\\n    Int2048,\\n    Uint24,\\n    Uint40,\\n    Uint48,\\n    Uint56,\\n    Uint72,\\n    Uint80,\\n    Uint88,\\n    Uint96,\\n    Uint104,\\n    Uint112,\\n    Uint120,\\n    Uint136,\\n    Uint144,\\n    Uint152,\\n    Uint168,\\n    Uint176,\\n    Uint184,\\n    Uint192,\\n    Uint200,\\n    Uint208,\\n    Uint216,\\n    Uint224,\\n    Uint232,\\n    Uint240,\\n    Uint248,\\n    Int24,\\n    Int40,\\n    Int48,\\n    Int56,\\n    Int72,\\n    Int80,\\n    Int88,\\n    Int96,\\n    Int104,\\n    Int112,\\n    Int120,\\n    Int136,\\n    Int144,\\n    Int152,\\n    Int168,\\n    Int176,\\n    Int184,\\n    Int192,\\n    Int200,\\n    Int208,\\n    Int216,\\n    Int224,\\n    Int232,\\n    Int240,\\n    Int248\\n}\\n\",\"keccak256\":\"0x945f006108fab92cb082a6e5a80525953f17b8d8dcf88a283a83fc80c765497a\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhevm/solidity/lib/Impl.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {FheType} from \\\"./FheType.sol\\\";\\n\\n/**\\n * @title   FHEVMConfigStruct\\n * @notice  This struct contains all addresses of core contracts, which are needed in a typical dApp.\\n */\\nstruct FHEVMConfigStruct {\\n    address ACLAddress;\\n    address FHEVMExecutorAddress;\\n    address KMSVerifierAddress;\\n    address InputVerifierAddress;\\n}\\n\\n/**\\n * @title   DecryptionRequestsStruct\\n * @notice  This struct contains the address of the decryption oracle contract,\\n *          the internal counter for requestIDs generated by the dapp,\\n *          and the mapping from internal requestIDs to list of handles requested for decryption.\\n */\\nstruct DecryptionRequestsStruct {\\n    address DecryptionOracleAddress;\\n    uint256 counterRequest;\\n    mapping(uint256 => bytes32[]) requestedHandles;\\n}\\n\\n/**\\n * @title   IFHEVMExecutor\\n * @notice  This interface contains all functions to conduct FHE operations.\\n */\\ninterface IFHEVMExecutor {\\n    /**\\n     * @notice              Computes fheAdd operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheAdd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheSub operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheSub(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheMul operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheMul(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheDiv operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheDiv(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheRem operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheRem(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheBitAnd operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheBitAnd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheBitOr operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheBitOr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheBitXor operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheBitXor(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheShl operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheShl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheShr operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheShr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheRotl operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheRotl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheRotr operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheRotr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheEq operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheEq(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheNe operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheNe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheGe operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheGe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheGt operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheGt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheLe operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheLe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheLt operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheLt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheMin operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheMin(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheMax operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheMax(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheNeg operation.\\n     * @param ct            Ct\\n     * @return result       Result.\\n     */\\n    function fheNeg(bytes32 ct) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheNot operation.\\n     * @param ct            Ct\\n     * @return result       Result.\\n     */\\n    function fheNot(bytes32 ct) external returns (bytes32 result);\\n    /**\\n     * @notice                Verifies the ciphertext.\\n     * @param inputHandle     Input handle.\\n     * @param callerAddress   Address of the caller.\\n     * @param inputProof      Input proof.\\n     * @param inputType       Input type.\\n     * @return result         Result.\\n     */\\n    function verifyCiphertext(\\n        bytes32 inputHandle,\\n        address callerAddress,\\n        bytes memory inputProof,\\n        FheType inputType\\n    ) external returns (bytes32 result);\\n\\n    /**\\n     * @notice          Performs the casting to a target type.\\n     * @param ct        Value to cast.\\n     * @param toType    Target type.\\n     * @return result   Result value of the target type.\\n     */\\n    function cast(bytes32 ct, FheType toType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice          Does trivial encryption.\\n     * @param ct        Value to encrypt.\\n     * @param toType    Target type.\\n     * @return result   Result value of the target type.\\n     */\\n    function trivialEncrypt(uint256 ct, FheType toType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes FHEIfThenElse operation.\\n     * @param control       Control value.\\n     * @param ifTrue        If true.\\n     * @param ifFalse       If false.\\n     * @return result       Result.\\n     */\\n    function fheIfThenElse(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes FHERand operation.\\n     * @param randType      Type for the random result.\\n     * @return result       Result.\\n     */\\n    function fheRand(FheType randType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes FHERandBounded operation.\\n     * @param upperBound    Upper bound value.\\n     * @param randType      Type for the random result.\\n     * @return result       Result.\\n     */\\n    function fheRandBounded(uint256 upperBound, FheType randType) external returns (bytes32 result);\\n}\\n\\n/**\\n * @title   IACL.\\n * @notice  This interface contains all functions that are used to conduct operations\\n *          with the ACL contract.\\n */\\ninterface IACL {\\n    /**\\n     * @notice              Allows the use of handle by address account for this transaction.\\n     * @dev                 The caller must be allowed to use handle for allowTransient() to succeed.\\n     *                      If not, allowTransient() reverts.\\n     *                      The Coprocessor contract can always allowTransient(), contrarily to allow().\\n     * @param ciphertext    Ciphertext.\\n     * @param account       Address of the account.\\n     */\\n    function allowTransient(bytes32 ciphertext, address account) external;\\n\\n    /**\\n     * @notice              Allows the use of handle for the address account.\\n     * @dev                 The caller must be allowed to use handle for allow() to succeed. If not, allow() reverts.\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     */\\n    function allow(bytes32 handle, address account) external;\\n\\n    /**\\n     * @dev This function removes the transient allowances, which could be useful for integration with\\n     *      Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorage() external;\\n\\n    /**\\n     * @notice              Returns whether the account is allowed to use the handle, either due to\\n     *                      allowTransient() or allow().\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     * @return isAllowed    Whether the account can access the handle.\\n     */\\n    function isAllowed(bytes32 handle, address account) external view returns (bool);\\n\\n    /**\\n     * @notice              Allows a list of handles to be decrypted.\\n     * @param handlesList   List of handles.\\n     */\\n    function allowForDecryption(bytes32[] memory handlesList) external;\\n\\n    /**\\n     * @notice                  Returns wether a handle is allowed to be publicly decrypted.\\n     * @param handle            Handle.\\n     * @return isDecryptable    Whether the handle can be publicly decrypted.\\n     */\\n    function isAllowedForDecryption(bytes32 handle) external view returns (bool);\\n}\\n\\n/**\\n * @title IInputVerifier\\n * @notice This interface contains the only function required from InputVerifier.\\n */\\ninterface IInputVerifier {\\n    /**\\n     * @dev This function removes the transient allowances, which could be useful for integration with\\n     *      Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorage() external;\\n}\\n\\n/**\\n * @title   Impl\\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\\n */\\nlibrary Impl {\\n    /// keccak256(abi.encode(uint256(keccak256(\\\"fhevm.storage.FHEVMConfig\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant FHEVMConfigLocation = 0xed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600;\\n\\n    /// keccak256(abi.encode(uint256(keccak256(\\\"fhevm.storage.DecryptionRequests\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant DecryptionRequestsStorageLocation =\\n        0x5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d00;\\n\\n    /**\\n     * @dev Returns the FHEVM config.\\n     */\\n    function getFHEVMConfig() internal pure returns (FHEVMConfigStruct storage $) {\\n        assembly {\\n            $.slot := FHEVMConfigLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the DecryptionRequestsStruct storage struct.\\n     */\\n    function getDecryptionRequests() internal pure returns (DecryptionRequestsStruct storage $) {\\n        assembly {\\n            $.slot := DecryptionRequestsStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @notice            Sets the coprocessor addresses.\\n     * @param fhevmConfig FHEVM config struct that contains contract addresses.\\n     */\\n    function setCoprocessor(FHEVMConfigStruct memory fhevmConfig) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        $.ACLAddress = fhevmConfig.ACLAddress;\\n        $.FHEVMExecutorAddress = fhevmConfig.FHEVMExecutorAddress;\\n        $.KMSVerifierAddress = fhevmConfig.KMSVerifierAddress;\\n        $.InputVerifierAddress = fhevmConfig.InputVerifierAddress;\\n    }\\n\\n    /**\\n     * @notice                 Sets the decryption oracle address.\\n     * @param decryptionOracle The decryption oracle address.\\n     */\\n    function setDecryptionOracle(address decryptionOracle) internal {\\n        DecryptionRequestsStruct storage $ = getDecryptionRequests();\\n        $.DecryptionOracleAddress = decryptionOracle;\\n    }\\n\\n    function add(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheAdd(lhs, rhs, scalarByte);\\n    }\\n\\n    function sub(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheSub(lhs, rhs, scalarByte);\\n    }\\n\\n    function mul(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheMul(lhs, rhs, scalarByte);\\n    }\\n\\n    function div(bytes32 lhs, bytes32 rhs) internal returns (bytes32 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheDiv(lhs, rhs, scalarByte);\\n    }\\n\\n    function rem(bytes32 lhs, bytes32 rhs) internal returns (bytes32 result) {\\n        bytes1 scalarByte = 0x01;\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheRem(lhs, rhs, scalarByte);\\n    }\\n\\n    function and(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheBitAnd(lhs, rhs, scalarByte);\\n    }\\n\\n    function or(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheBitOr(lhs, rhs, scalarByte);\\n    }\\n\\n    function xor(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheBitXor(lhs, rhs, scalarByte);\\n    }\\n\\n    function shl(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheShl(lhs, rhs, scalarByte);\\n    }\\n\\n    function shr(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheShr(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotl(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheRotl(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotr(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheRotr(lhs, rhs, scalarByte);\\n    }\\n\\n    function eq(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function ge(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheGe(lhs, rhs, scalarByte);\\n    }\\n\\n    function gt(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheGt(lhs, rhs, scalarByte);\\n    }\\n\\n    function le(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheLe(lhs, rhs, scalarByte);\\n    }\\n\\n    function lt(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheLt(lhs, rhs, scalarByte);\\n    }\\n\\n    function min(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheMin(lhs, rhs, scalarByte);\\n    }\\n\\n    function max(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheMax(lhs, rhs, scalarByte);\\n    }\\n\\n    function neg(bytes32 ct) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheNeg(ct);\\n    }\\n\\n    function not(bytes32 ct) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheNot(ct);\\n    }\\n\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheIfThenElse(control, ifTrue, ifFalse);\\n    }\\n\\n    /**\\n     * @notice              Verifies the ciphertext (FHEVMExecutor) and allows transient (ACL).\\n     * @param inputHandle   Input handle.\\n     * @param inputProof    Input proof.\\n     * @param toType        Input type.\\n     * @return result       Result.\\n     */\\n    function verify(bytes32 inputHandle, bytes memory inputProof, FheType toType) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).verifyCiphertext(inputHandle, msg.sender, inputProof, toType);\\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\\n    }\\n\\n    /**\\n     * @notice            Performs the casting to a target type.\\n     * @param ciphertext  Ciphertext to cast.\\n     * @param toType      Target type.\\n     * @return result     Result value of the target type.\\n     */\\n    function cast(bytes32 ciphertext, FheType toType) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).cast(ciphertext, toType);\\n    }\\n\\n    /**\\n     * @notice          Does trivial encryption.\\n     * @param value     Value to encrypt.\\n     * @param toType    Target type.\\n     * @return result   Result value of the target type.\\n     */\\n    function trivialEncrypt(uint256 value, FheType toType) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).trivialEncrypt(value, toType);\\n    }\\n\\n    function rand(FheType randType) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheRand(randType);\\n    }\\n\\n    function randBounded(uint256 upperBound, FheType randType) internal returns (bytes32 result) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        result = IFHEVMExecutor($.FHEVMExecutorAddress).fheRandBounded(upperBound, randType);\\n    }\\n\\n    /**\\n     * @notice              Allows the use of handle by address account for this transaction.\\n     * @dev                 The caller must be allowed to use handle for allowTransient() to succeed.\\n     *                      If not, allowTransient() reverts.\\n     *                      The Coprocessor contract can always allowTransient(), contrarily to allow().\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     */\\n    function allowTransient(bytes32 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allowTransient(handle, account);\\n    }\\n\\n    /**\\n     * @notice              Allows the use of handle for the address account.\\n     * @dev                 The caller must be allowed to use handle for allow() to succeed. If not, allow() reverts.\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     */\\n    function allow(bytes32 handle, address account) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).allow(handle, account);\\n    }\\n\\n    /**\\n     * @notice              Allows the handle to be publicly decryptable.\\n     * @dev                 The caller must be allowed to use handle for makePubliclyDecryptable() to succeed.\\n     *                      If not, makePubliclyDecryptable() reverts.\\n     * @param handle        Handle.\\n     */\\n    function makePubliclyDecryptable(bytes32 handle) internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        bytes32[] memory handleArray = new bytes32[](1);\\n        handleArray[0] = handle;\\n        IACL($.ACLAddress).allowForDecryption(handleArray);\\n    }\\n\\n    /**\\n     * @dev This function removes the transient allowances in the ACL, which could be useful for integration\\n     *      with Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorageACL() internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IACL($.ACLAddress).cleanTransientStorage();\\n    }\\n\\n    /**\\n     * @dev This function removes the transient proofs in the InputVerifier, which could be useful for integration\\n     *      with Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorageInputVerifier() internal {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        IInputVerifier($.InputVerifierAddress).cleanTransientStorage();\\n    }\\n\\n    /**\\n     * @notice              Returns whether the account is allowed to use the handle, either due to\\n     *                      allowTransient() or allow().\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     * @return isAllowed    Whether the account can access the handle.\\n     */\\n    function isAllowed(bytes32 handle, address account) internal view returns (bool) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        return IACL($.ACLAddress).isAllowed(handle, account);\\n    }\\n\\n    /**\\n     * @notice              Returns whether the handle is allowed to be publicly decrypted.\\n     * @param handle        Handle.\\n     * @return isAllowed    Whether the handle can be publicly decrypted.\\n     */\\n    function isPubliclyDecryptable(bytes32 handle) internal view returns (bool) {\\n        FHEVMConfigStruct storage $ = getFHEVMConfig();\\n        return IACL($.ACLAddress).isAllowedForDecryption(handle);\\n    }\\n}\\n\",\"keccak256\":\"0xf4d58b67ea3f81a56c5c8a66ad9843631909b8c393b87e0b42a7a3eb3d5fedb8\",\"license\":\"BSD-3-Clause-Clear\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0x74ed01eb66b923d0d0cfe3be84604ac04b76482a55f9dd655e1ef4d367f95bc2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\\n * consider using {ReentrancyGuardTransient} instead.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x11a5a79827df29e915a12740caf62fe21ebe27c08c9ae3e09abe9ee3ba3866d3\",\"license\":\"MIT\"},\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\",\"keccak256\":\"0x8a3c5c449d4b7cd76513ed6995f4b86e4a86f222c770f8442f5fc128ce29b4d2\"},\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\",\"keccak256\":\"0x744e30c133bd0f7ca9e7163433cf6d72f45c6bb1508c2c9c02f1a6db796ae59d\"},\"@zama-fhe/oracle-solidity/address/ZamaOracleAddress.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n\\npragma solidity ^0.8.24;\\n\\naddress constant SepoliaZamaOracleAddress = 0xa02Cda4Ca3a71D7C46997716F4283aa851C28812;\\n\",\"keccak256\":\"0x1e1117254b0e777ecbb902f3b9bb7d0b10920b7896e5eaa62b5163046685b28b\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/ConfidentialDCABatch.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport {FHE, externalEuint64, euint64, ebool} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IUniswapV2Router02} from \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport {SepoliaConfig} from \\\"@fhevm/solidity/config/ZamaConfig.sol\\\";\\nimport \\\"./types/PairTypes.sol\\\";\\nimport \\\"./types/BatchTypes.sol\\\";\\nimport \\\"./types/PlanTypes.sol\\\";\\nimport \\\"./events/Pair.sol\\\";\\nimport \\\"./events/Plan.sol\\\";\\nimport \\\"./events/Batch.sol\\\";\\nimport \\\"./events/Transfer.sol\\\";\\nimport \\\"./errors/Pair.sol\\\";\\nimport \\\"./errors/Plan.sol\\\";\\nimport \\\"./errors/Batch.sol\\\";\\n\\ncontract ConfidentialDCABatch is Ownable, ReentrancyGuard, SepoliaConfig {\\n    IERC20 public immutable USDC;\\n    IUniswapV2Router02 public immutable router;\\n    uint256 public constant BATCH_LIMIT = 10;\\n\\n    constructor(address _usdc, address _router) Ownable(msg.sender) {\\n        USDC = IERC20(_usdc);\\n        router = IUniswapV2Router02(_router);\\n    }\\n\\n    // ====== trading pairs ======\\n    // keccak256(from,to) => allowed\\n    mapping(bytes32 key => bool allowed) public allowedPairs;\\n    mapping(bytes32 key => uint256 pairIndex) private pairIndex;\\n    Pair[] public allPairs;\\n\\n    function getAllPairs() public view returns (Pair[] memory) {\\n        return allPairs;\\n    }\\n\\n    function updateAllowedPair(\\n        address fromToken,\\n        string memory fromName,\\n        uint8 fromDecimals,\\n        address toToken,\\n        string memory toName,\\n        uint8 toDecimals,\\n        bool allowed\\n    ) external onlyOwner {\\n        if (fromToken != address(USDC)) {\\n            revert InvalidFromToken(fromToken, address(USDC));\\n        }\\n\\n        bytes32 key = keccak256(abi.encode(fromToken, toToken));\\n        allowedPairs[key] = allowed;\\n\\n        if (allowed) {\\n            if (pairIndex[key] != 0) {\\n                revert PairAlreadyExists(key);\\n            }\\n\\n            allPairs.push(Pair(fromToken, fromName, fromDecimals, toToken, toName, toDecimals, allowed));\\n            pairIndex[key] = allPairs.length; // store index+1\\n        } else {\\n            uint256 idx = pairIndex[key];\\n            if (idx == 0) {\\n                revert PairNotFound(key);\\n            }\\n            uint256 lastIdx = allPairs.length;\\n\\n            if (idx != lastIdx) {\\n                // swap with last\\n                Pair memory lastPair = allPairs[lastIdx - 1];\\n                allPairs[idx - 1] = lastPair;\\n                pairIndex[keccak256(abi.encode(lastPair.from, lastPair.to))] = idx;\\n            }\\n\\n            allPairs.pop();\\n            delete pairIndex[key];\\n        }\\n\\n        emit PairUpdated(fromToken, toToken, allowed);\\n    }\\n\\n    // ====== Plans ======\\n\\n    uint256 public nextPlanId = 1;\\n    mapping(uint256 => Plan) public plans;\\n\\n    // --- Per-request tracking ---\\n    mapping(uint256 => address) public requestIdToSender; // who initiated the request\\n    mapping(uint256 => address) public requestIdToRecipient; // who receives the tokens\\n    mapping(uint256 => bool) public requestProcessed; // basic replay/cleanup guard\\n    mapping(uint256 => uint256) public requestIdToPlanId; // basic replay/cleanup guard\\n\\n    function createPlan(\\n        address toToken,\\n        uint64 startTime,\\n        externalEuint64 encInterval,\\n        externalEuint64 encTotalAmount,\\n        externalEuint64 encAmountPerInterval,\\n        externalEuint64 encTotalIntervals,\\n        bytes calldata proofs\\n    ) external returns (uint256 planId) {\\n        if (!allowedPairs[keccak256(abi.encode(address(USDC), toToken))]) {\\n            revert PairNotAllowed(address(USDC), toToken);\\n        }\\n\\n        euint64 a = FHE.fromExternal(encAmountPerInterval, proofs);\\n        euint64 n = FHE.fromExternal(encTotalIntervals, proofs);\\n        euint64 interval = FHE.fromExternal(encInterval, proofs);\\n        euint64 totalAmount = FHE.fromExternal(encTotalAmount, proofs);\\n\\n        planId = nextPlanId++;\\n        Plan storage p = plans[planId];\\n        p.owner = msg.sender;\\n        p.tokens.fromToken = address(USDC);\\n        p.tokens.toToken = toToken;\\n        p.timing.startTime = startTime;\\n        p.timing.interval = interval;\\n        p.amounts.amountPerInterval = a;\\n        p.timing.totalIntervals = n;\\n        p.timing.executedIntervals = FHE.asEuint64(0);\\n        p.amounts.pendingOut = FHE.asEuint64(0);\\n        p.timing.lastExecutionTime = FHE.asEuint64(0);\\n        p.amounts.totalAmount = totalAmount;\\n        p.amounts.remainingAmount = totalAmount;\\n        p.status = PlanStatus.Pending;\\n        p.meta.planId = planId;\\n\\n        // allow contract to reuse ciphertexts\\n        FHE.allowThis(p.amounts.amountPerInterval);\\n        FHE.allowThis(p.timing.totalIntervals);\\n        FHE.allowThis(p.timing.executedIntervals);\\n        FHE.allowThis(p.amounts.pendingOut);\\n        FHE.allowThis(p.timing.interval);\\n        FHE.allowThis(p.amounts.totalAmount);\\n        FHE.allowThis(p.timing.lastExecutionTime);\\n        FHE.allowThis(p.amounts.remainingAmount);\\n\\n        // allow user to reuse ciphertexts\\n        FHE.allow(p.amounts.amountPerInterval, msg.sender);\\n        FHE.allow(p.timing.totalIntervals, msg.sender);\\n        FHE.allow(p.timing.executedIntervals, msg.sender);\\n        FHE.allow(p.amounts.pendingOut, msg.sender);\\n        FHE.allow(p.timing.interval, msg.sender);\\n        FHE.allow(p.amounts.totalAmount, msg.sender);\\n        FHE.allow(p.timing.lastExecutionTime, msg.sender);\\n        FHE.allow(p.amounts.remainingAmount, msg.sender);\\n\\n        bytes32[] memory cts = new bytes32[](1);\\n        cts[0] = FHE.toBytes32(totalAmount);\\n\\n        // Ask to decrypt and call back `onCreatePlanDecryption`\\n        uint256 reqId = FHE.requestDecryption(cts, this.onCreatePlanDecryption.selector);\\n\\n        // Track the request so we know who initiated it and who should receive the payout\\n        requestIdToSender[reqId] = msg.sender;\\n        requestIdToRecipient[reqId] = address(this);\\n        requestIdToPlanId[reqId] = planId;\\n\\n        p.meta.requestId = reqId;\\n\\n        emit PlanCreated(planId, msg.sender);\\n    }\\n\\n    function onCreatePlanDecryption(\\n        uint256 requestId,\\n        uint64 decryptedAmount,\\n        bytes[] memory signatures\\n    ) public returns (bool success) {\\n        if (requestProcessed[requestId]) {\\n            revert RequestAlreadyProcessed(requestId);\\n        }\\n\\n        address sender = requestIdToSender[requestId];\\n        address recipient = requestIdToRecipient[requestId];\\n\\n        FHE.checkSignatures(requestId, signatures);\\n\\n        uint256 amount = uint256(decryptedAmount);\\n\\n        requestProcessed[requestId] = true;\\n\\n        Plan storage p = plans[requestIdToPlanId[requestId]];\\n        if (p.meta.requestId != requestId) {\\n            revert RequestAlreadyProcessing(p.meta.requestId);\\n        }\\n        p.meta.requestId = 0;\\n\\n        try this._escrow(sender, amount) returns (bool ok) {\\n            if (ok) {\\n                p.status = PlanStatus.Active;\\n                emit TransferCompleted(requestId, sender, recipient, amount);\\n                return true;\\n            } else {\\n                emit TransferFailed(requestId, sender, recipient, amount, \\\"Token transfer returned false\\\");\\n                return false;\\n            }\\n        } catch Error(string memory reason) {\\n            emit TransferFailed(requestId, sender, recipient, amount, reason);\\n            return false;\\n        } catch {\\n            emit TransferFailed(requestId, sender, recipient, amount, \\\"Token transfer failed\\\");\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Externalized transfer to keep a clean try/catch surface.\\n     */\\n    function _escrow(address from, uint256 amount) external returns (bool) {\\n        return USDC.transferFrom(from, address(this), amount);\\n    }\\n\\n    function depositToPlan(uint256 planId) external nonReentrant {\\n        Plan storage p = plans[planId];\\n        if (p.status != PlanStatus.Pending) {\\n            revert InvalidPlanStatus(p.status, PlanStatus.Pending);\\n        }\\n\\n        if (p.owner != msg.sender) {\\n            revert NotPlanOwner(msg.sender, p.owner);\\n        }\\n\\n        if (p.tokens.fromToken != address(USDC)) {\\n            revert InvalidFromToken(p.tokens.fromToken, address(USDC));\\n        }\\n\\n        if (p.meta.requestId != 0) {\\n            revert RequestAlreadyProcessing(p.meta.requestId);\\n        }\\n\\n        bytes32[] memory cts = new bytes32[](1);\\n        cts[0] = FHE.toBytes32(p.amounts.totalAmount);\\n\\n        uint256 reqId = FHE.requestDecryption(cts, this.onCreatePlanDecryption.selector);\\n\\n        requestIdToSender[reqId] = msg.sender;\\n        requestIdToRecipient[reqId] = address(this);\\n        requestIdToPlanId[reqId] = planId;\\n\\n        p.meta.requestId = reqId;\\n        emit PlanDeposit(planId, p.amounts.totalAmount);\\n    }\\n\\n    function pausePlan(uint256 planId) external {\\n        Plan storage p = plans[planId];\\n        if (p.owner != msg.sender) {\\n            revert NotPlanOwner(msg.sender, p.owner);\\n        }\\n\\n        if (p.status != PlanStatus.Active) {\\n            revert InvalidPlanStatus(p.status, PlanStatus.Active);\\n        }\\n\\n        p.status = PlanStatus.Paused;\\n    }\\n\\n    function resumePlan(uint256 planId) external {\\n        Plan storage p = plans[planId];\\n\\n        if (p.owner != msg.sender) {\\n            revert NotPlanOwner(msg.sender, p.owner);\\n        }\\n\\n        if (p.status != PlanStatus.Paused) {\\n            revert InvalidPlanStatus(p.status, PlanStatus.Paused);\\n        }\\n\\n        p.status = PlanStatus.Active;\\n    }\\n\\n    // --- Per-request tracking ---\\n    mapping(uint256 => address) public cancelReqIdToSender; // who initiated the request\\n    mapping(uint256 => bool) public cancelRequestProcessed; // basic replay/cleanup guard\\n    mapping(uint256 => uint256) public cancelRequestIdToPlanId; // basic replay/cleanup guard\\n\\n    // Cancel a plan.\\n    function cancelPlan(uint256 planId) external {\\n        Plan storage p = plans[planId];\\n\\n        if (p.owner != msg.sender) {\\n            revert NotPlanOwner(msg.sender, p.owner);\\n        }\\n\\n        if (p.status == PlanStatus.Canceled || p.status == PlanStatus.Completed) {\\n            revert InvalidPlanStatus(p.status, PlanStatus.Active);\\n        }\\n\\n        bytes32[] memory cts = new bytes32[](1);\\n        cts[0] = FHE.toBytes32(p.amounts.remainingAmount);\\n\\n        // Ask to decrypt and call back `onCancelPlanDecrypt`\\n        uint256 reqId = FHE.requestDecryption(cts, this.onCancelPlanDecrypt.selector);\\n\\n        cancelReqIdToSender[reqId] = msg.sender;\\n        cancelRequestProcessed[reqId] = false;\\n        cancelRequestIdToPlanId[reqId] = planId;\\n\\n        emit PlanCancelled(planId);\\n    }\\n\\n    function onCancelPlanDecrypt(\\n        uint256 requestId,\\n        uint64 decryptedAmount,\\n        bytes[] memory signatures\\n    ) public returns (bool success) {\\n        if (cancelRequestProcessed[requestId]) {\\n            revert CancelRequestAlreadyProcessed(requestId);\\n        }\\n\\n        address sender = cancelReqIdToSender[requestId];\\n\\n        FHE.checkSignatures(requestId, signatures);\\n\\n        uint256 amount = uint256(decryptedAmount);\\n\\n        cancelRequestProcessed[requestId] = true;\\n\\n        Plan storage p = plans[cancelRequestIdToPlanId[requestId]];\\n        try this._refund(sender, amount) returns (bool ok) {\\n            if (!ok) {\\n                p.meta.requestId = 0;\\n                revert RefundFailed(sender, amount);\\n            }\\n            p.status = PlanStatus.Canceled;\\n            p.meta.requestId = 0;\\n            return true;\\n        } catch Error(string memory reason) {\\n            p.meta.requestId = 0;\\n            revert RefundReverted(sender, reason);\\n        } catch {\\n            p.meta.requestId = 0;\\n            revert RefundUnknownError(sender, amount);\\n        }\\n    }\\n\\n    function _refund(address to, uint256 amount) external returns (bool) {\\n        return USDC.transfer(to, amount);\\n    }\\n\\n    // ====== Keeper (bot) role ======\\n    mapping(address => bool) public executors; // keeper(s)\\n    event ExecutorSet(address indexed executor, bool allowed);\\n\\n    modifier onlyExecutor() {\\n        require(executors[msg.sender] || msg.sender == owner(), \\\"not executor\\\");\\n        _;\\n    }\\n\\n    function setExecutor(address who, bool allowed) external onlyOwner {\\n        executors[who] = allowed;\\n        emit ExecutorSet(who, allowed);\\n    }\\n\\n    function _isPlanDue(Plan storage p) internal returns (ebool) {\\n        if (p.status != PlanStatus.Active) {\\n            return FHE.asEbool(false);\\n        }\\n\\n        euint64 nowEnc = FHE.asEuint64(uint64(block.timestamp));\\n        ebool isDue = FHE.gt(nowEnc, p.timing.startTime);\\n        ebool notFinished = FHE.lt(p.timing.executedIntervals, p.timing.totalIntervals);\\n        ebool notAlreadyExecuted = FHE.lt(p.timing.lastExecutionTime, nowEnc);\\n        ebool canExecute = FHE.and(FHE.and(isDue, notFinished), notAlreadyExecuted);\\n\\n        return canExecute;\\n    }\\n\\n    uint256 private nextBatchId = 1;\\n\\n    // Track batch progress for each trading pair\\n    mapping(bytes32 => uint256) public pairBatchCursor;\\n\\n    mapping(uint256 => Batch) public batches; // batchId => Batch\\n    mapping(uint256 => uint256) public batchReqIdToBatchId; // decryption requestId => batchId\\n\\n    function triggerBatch(address fromToken, address toToken) external {\\n        bytes32 key = keccak256(abi.encode(fromToken, toToken));\\n\\n        if (!allowedPairs[key]) {\\n            revert PairNotAllowed(fromToken, toToken);\\n        }\\n\\n        if (fromToken != address(USDC)) {\\n            revert InvalidFromToken(fromToken, address(USDC));\\n        }\\n\\n        uint64 slotTime = uint64(block.timestamp);\\n        euint64 slotEnc = FHE.asEuint64(slotTime);\\n\\n        uint256[] memory planBuf = new uint256[](BATCH_LIMIT);\\n        uint256 planCount = 0;\\n        euint64 totalInEnc = FHE.asEuint64(0);\\n        euint64[] memory amountsEnc = new euint64[](BATCH_LIMIT);\\n\\n        uint256 cursor = pairBatchCursor[key];\\n\\n        for (uint256 i = cursor; i < nextPlanId && planCount < BATCH_LIMIT; i++) {\\n            Plan storage pl = plans[i];\\n\\n            // public checks are fine\\n            if (pl.status != PlanStatus.Active) continue;\\n            if (pl.tokens.fromToken != fromToken) continue;\\n            if (pl.tokens.toToken != toToken) continue;\\n\\n            // encrypted checks\\n            ebool due = FHE.gt(slotEnc, FHE.asEuint64(pl.timing.startTime));\\n            ebool notFinished = FHE.lt(pl.timing.executedIntervals, pl.timing.totalIntervals);\\n            ebool canExecute = FHE.and(due, notFinished);\\n\\n            // clamp selected amount\\n            ebool remLessThanInterval = FHE.lt(pl.amounts.remainingAmount, pl.amounts.amountPerInterval);\\n            euint64 minAmt = FHE.select(remLessThanInterval, pl.amounts.remainingAmount, pl.amounts.amountPerInterval);\\n\\n            // select zero when not executable\\n            euint64 selectedAmt = FHE.select(canExecute, minAmt, FHE.asEuint64(0));\\n\\n            totalInEnc = FHE.add(totalInEnc, selectedAmt);\\n            pl.amounts.remainingAmount = FHE.sub(pl.amounts.remainingAmount, selectedAmt);\\n            FHE.allowThis(pl.amounts.remainingAmount);\\n            FHE.allow(pl.amounts.remainingAmount, pl.owner);\\n\\n            euint64 addOneOrZero = FHE.select(canExecute, FHE.asEuint64(1), FHE.asEuint64(0));\\n            pl.timing.executedIntervals = FHE.add(pl.timing.executedIntervals, addOneOrZero);\\n            FHE.allowThis(pl.timing.executedIntervals);\\n            FHE.allow(pl.timing.executedIntervals, pl.owner);\\n\\n            planBuf[planCount] = i;\\n            amountsEnc[planCount] = selectedAmt;\\n            planCount++;\\n        }\\n\\n        pairBatchCursor[key] = cursor + planCount;\\n\\n        if (pairBatchCursor[key] >= nextPlanId) {\\n            pairBatchCursor[key] = 0;\\n        }\\n\\n        if (planCount == 0) {\\n            revert NoEligiblePlans(key);\\n        }\\n\\n        // copy into proper array\\n        uint256[] memory planIds = new uint256[](planCount);\\n        euint64[] memory encryptedShares = new euint64[](planCount);\\n        for (uint256 j = 0; j < planCount; j++) {\\n            planIds[j] = planBuf[j];\\n            encryptedShares[j] = amountsEnc[j];\\n            FHE.allowThis(encryptedShares[j]);\\n        }\\n\\n        // create batch\\n        uint256 batchId = nextBatchId++;\\n        Batch storage b = batches[batchId];\\n        b.batchId = batchId;\\n        b.fromToken = fromToken;\\n        b.toToken = toToken;\\n        b.planIds = planIds;\\n        b.encryptedShares = encryptedShares;\\n        b.totalInEnc = totalInEnc;\\n        b.slotTime = slotTime;\\n        b.executed = false;\\n\\n        // request decryption of the batch total\\n        bytes32[] memory cts = new bytes32[](1);\\n        cts[0] = FHE.toBytes32(totalInEnc);\\n\\n        uint256 reqId = FHE.requestDecryption(cts, this.onBatchAmount.selector);\\n        batchReqIdToBatchId[reqId] = batchId;\\n\\n        emit BatchTriggered(batchId, toToken, planCount);\\n    }\\n\\n    function onBatchAmount(\\n        uint256 requestId,\\n        uint256 decryptedValue,\\n        bytes[] memory signatures\\n    ) public returns (bool success) {\\n        uint256 batchId = batchReqIdToBatchId[requestId];\\n\\n        if (batchId == 0) {\\n            revert UnknownBatchRequest(requestId);\\n        }\\n\\n        FHE.checkSignatures(requestId, signatures);\\n\\n        Batch storage b = batches[batchId];\\n        if (b.executed) {\\n            revert BatchAlreadyExecuted(batchId);\\n        }\\n\\n        uint256 amountInLocal = decryptedValue;\\n        if (amountInLocal == 0) {\\n            revert ZeroBatchInput(batchId);\\n        }\\n\\n        // Do the swap via Uniswap V2\\n        address[] memory path = new address[](2);\\n        path[0] = b.fromToken;\\n        path[1] = b.toToken;\\n\\n        // approve router for exactly amountIn\\n        IERC20(b.fromToken).approve(address(router), 0);\\n        IERC20(b.fromToken).approve(address(router), amountInLocal);\\n\\n        uint256[] memory amounts = router.swapExactTokensForTokens(\\n            amountInLocal,\\n            0, // TODO: calculate slippage\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 amountOutLocal = amounts[amounts.length - 1];\\n        euint64 amountOutEnc = FHE.asEuint64(uint64(amountOutLocal));\\n        FHE.allowThis(amountOutEnc);\\n\\n        uint256 planCount = b.planIds.length;\\n        for (uint256 i = 0; i < planCount; i++) {\\n            // encrypted input share for this plan\\n            euint64 planInEnc = b.encryptedShares[i];\\n\\n            // encrypted output share = (amountOutEnc * planInEnc) / totalInEnc\\n            euint64 prod = FHE.mul(amountOutEnc, planInEnc);\\n            FHE.allowThis(prod);\\n            euint64 shareOutEnc = FHE.div(prod, uint64(amountInLocal));\\n            // credit user escrow balance (still encrypted)\\n            Plan storage pl = plans[b.planIds[i]];\\n            pl.amounts.pendingOut = FHE.add(pl.amounts.pendingOut, shareOutEnc);\\n\\n            // allow contract + user to see their new encrypted pendingOut\\n            FHE.allowThis(pl.amounts.pendingOut);\\n            FHE.allow(pl.amounts.pendingOut, pl.owner);\\n        }\\n\\n        b.executed = true;\\n\\n        emit BatchExecuted(batchId, amountInLocal, amountOutLocal);\\n        return true;\\n    }\\n\\n    mapping(uint256 => uint256) withdrawReqToPlanId;\\n\\n    function withdraw(uint256 planId) external {\\n        Plan storage pl = plans[planId];\\n        if (pl.owner == address(0)) {\\n            revert PlanNotFound(planId);\\n        }\\n\\n        if (pl.owner != msg.sender) {\\n            revert NotPlanOwner(msg.sender, pl.owner);\\n        }\\n\\n        // request decryption of the batch total\\n        bytes32[] memory cts = new bytes32[](1);\\n        cts[0] = FHE.toBytes32(pl.amounts.pendingOut);\\n\\n        uint256 reqId = FHE.requestDecryption(cts, this.onWithdrawCallback.selector);\\n        withdrawReqToPlanId[reqId] = planId;\\n    }\\n\\n    function onWithdrawCallback(\\n        uint256 requestId,\\n        uint256 decryptedValue,\\n        bytes[] memory signatures\\n    ) public returns (bool success) {\\n        uint256 planId = withdrawReqToPlanId[requestId];\\n        if (planId == 0) {\\n            revert InvalidWithdrawRequest(requestId);\\n        }\\n\\n        FHE.checkSignatures(requestId, signatures);\\n\\n        Plan memory p = plans[planId];\\n        IERC20 destination = IERC20(p.tokens.toToken);\\n\\n        try destination.transfer(p.owner, decryptedValue) returns (bool ok) {\\n            if (!ok) {\\n                revert ERC20TransferFailed(address(destination), p.owner, decryptedValue);\\n            }\\n        } catch Error(string memory reason) {\\n            revert ERC20TransferReverted(address(destination), reason);\\n        } catch {\\n            revert ERC20TransferUnknownError(address(destination));\\n        }\\n        return true;\\n    }\\n}\\n\",\"keccak256\":\"0xc964442f0f3ebee06baf46c3db6a4516bcb6498e19d36d867ea93ad772689f1a\",\"license\":\"MIT\"},\"contracts/errors/Batch.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nerror UnknownBatchRequest(uint256 requestId);\\nerror BatchAlreadyExecuted(uint256 batchId);\\nerror ZeroBatchInput(uint256 batchId);\\nerror NoEligiblePlans(bytes32 pairKey);\\n\",\"keccak256\":\"0xfb80ad9bb6514d2576023352ea04cf2554af34297725f5b5093f23de8ddbbcce\",\"license\":\"MIT\"},\"contracts/errors/Pair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nerror InvalidFromToken(address provided, address expected);\\nerror PairAlreadyExists(bytes32 key);\\nerror PairNotFound(bytes32 key);\\nerror PairNotAllowed(address fromToken, address toToken);\\n\",\"keccak256\":\"0x37f1017ad5ef4fb81c451438715633145f57c08e3385153b29737666de454d9c\",\"license\":\"MIT\"},\"contracts/errors/Plan.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport \\\"../types/PlanTypes.sol\\\";\\n\\nerror RequestAlreadyProcessed(uint256 requestId);\\nerror RequestAlreadyProcessing(uint256 requestId);\\n\\nerror InvalidPlanStatus(PlanStatus current, PlanStatus expected);\\nerror NotPlanOwner(address caller, address owner);\\nerror PlanNotFound(uint256 planId);\\nerror InvalidWithdrawRequest(uint256 requestId);\\nerror CancelRequestAlreadyProcessed(uint256 requestId);\\nerror RefundFailed(address sender, uint256 amount);\\nerror RefundReverted(address sender, string reason);\\nerror RefundUnknownError(address sender, uint256 amount);\\n\\nerror ERC20TransferFailed(address token, address to, uint256 amount);\\nerror ERC20TransferReverted(address token, string reason);\\nerror ERC20TransferUnknownError(address token);\\n\",\"keccak256\":\"0xf8f6e76fae86965bbcc3f1362a71f10bd56fb0892fd78bae215e6b52ba544168\",\"license\":\"MIT\"},\"contracts/events/Batch.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nevent BatchTriggered(uint256 indexed batchId, address indexed toToken, uint256 planCount);\\nevent BatchExecuted(uint256 indexed batchId, uint256 amountIn, uint256 amountOut);\\n\",\"keccak256\":\"0xba841d33a87ef52fe2d6a24878c3cf1c92f4cfcc77f4cb7230945ea7c7fbb1df\",\"license\":\"MIT\"},\"contracts/events/Pair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nevent PairUpdated(address indexed fromToken, address indexed toToken, bool allowed);\\n\",\"keccak256\":\"0x80d4446f3abbe485f8ef521f810a0ff9549dd4369e1a484d5f59d588728872ca\",\"license\":\"MIT\"},\"contracts/events/Plan.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport {euint64} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\n\\nevent PlanCreated(uint256 indexed planId, address indexed owner);\\nevent PlanDeposit(uint256 indexed planId, euint64 amount);\\nevent PlanCancelled(uint256 indexed planId);\\nevent WithdrawPlan(uint256 indexed planId);\\n\\n\",\"keccak256\":\"0x7812c88f8378d8e82584ba6fd96aed7cf32ce0acac3ebea7553f492afee8d38f\",\"license\":\"MIT\"},\"contracts/events/Transfer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\n\\nevent TransferCompleted(\\n        uint256 indexed requestId,\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 amount\\n    );\\n    event TransferFailed(\\n        uint256 indexed requestId,\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 amount,\\n        string reason\\n    );\",\"keccak256\":\"0x8ac7a99ed7fe87856e7cfb74631698c5ce171ae0bfd9e5f4644b7816f56bdd6e\",\"license\":\"MIT\"},\"contracts/types/BatchTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport {euint64} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\n\\nstruct Batch {\\n    uint256 batchId;\\n    address fromToken;\\n    address toToken;\\n    uint256[] planIds; // list of plan IDs included\\n    euint64 totalInEnc; // total encrypted input from all plans\\n    uint64 slotTime; // block timestamp of batch\\n    bool executed; // whether swap+distribution has been completed\\n    euint64[] encryptedShares;\\n}\\n\",\"keccak256\":\"0x8cf5e24e578d4cab7ce580b6d9104ac1dda01745cec6c71727b35bce998c8755\",\"license\":\"MIT\"},\"contracts/types/PairTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nstruct Pair {\\n    address from;\\n    string fromName;\\n    uint8 fromDecimals;\\n    address to;\\n    string toName;\\n    uint8 toDecimals;\\n    bool allowed;\\n}\\n\",\"keccak256\":\"0x83b8d460a11600599e149ba2db17d1e79afdd32d9c05e4f2f79f3d42c882e650\",\"license\":\"MIT\"},\"contracts/types/PlanTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport {euint64} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\n\\nstruct PlanMeta {\\n    uint256 requestId;\\n    uint256 planId;\\n}\\n\\nstruct PlanTiming {\\n    uint64 startTime;\\n    euint64 interval;\\n    euint64 lastExecutionTime;\\n    euint64 totalIntervals;\\n    euint64 executedIntervals;\\n}\\n\\nstruct PlanAmounts {\\n    euint64 totalAmount;\\n    euint64 remainingAmount;\\n    euint64 amountPerInterval;\\n    euint64 pendingOut;\\n}\\n\\nstruct PlanTokens {\\n    address fromToken;\\n    address toToken;\\n}\\n\\nstruct Plan {\\n    address owner;\\n    PlanTokens tokens;\\n    PlanTiming timing;\\n    PlanAmounts amounts;\\n    PlanStatus status;\\n    PlanMeta meta;\\n}\\n\\nenum PlanStatus {\\n    Pending,\\n    Active,\\n    Paused,\\n    Completed,\\n    Canceled\\n}\\n\",\"keccak256\":\"0xf35907bc55db8c60e50325223a4658eb3b0f0c104eacaf1aae2f7c4178ab187b\",\"license\":\"MIT\"},\"encrypted-types/EncryptedTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\ntype ebool is bytes32;\\n\\ntype euint8 is bytes32;\\ntype euint16 is bytes32;\\ntype euint24 is bytes32;\\ntype euint32 is bytes32;\\ntype euint40 is bytes32;\\ntype euint48 is bytes32;\\ntype euint56 is bytes32;\\ntype euint64 is bytes32;\\ntype euint72 is bytes32;\\ntype euint80 is bytes32;\\ntype euint88 is bytes32;\\ntype euint96 is bytes32;\\ntype euint104 is bytes32;\\ntype euint112 is bytes32;\\ntype euint120 is bytes32;\\ntype euint128 is bytes32;\\ntype euint136 is bytes32;\\ntype euint144 is bytes32;\\ntype euint152 is bytes32;\\ntype euint160 is bytes32;\\ntype euint168 is bytes32;\\ntype euint176 is bytes32;\\ntype euint184 is bytes32;\\ntype euint192 is bytes32;\\ntype euint200 is bytes32;\\ntype euint208 is bytes32;\\ntype euint216 is bytes32;\\ntype euint224 is bytes32;\\ntype euint232 is bytes32;\\ntype euint240 is bytes32;\\ntype euint248 is bytes32;\\ntype euint256 is bytes32;\\n\\ntype eint8 is bytes32;\\ntype eint16 is bytes32;\\ntype eint24 is bytes32;\\ntype eint32 is bytes32;\\ntype eint40 is bytes32;\\ntype eint48 is bytes32;\\ntype eint56 is bytes32;\\ntype eint64 is bytes32;\\ntype eint72 is bytes32;\\ntype eint80 is bytes32;\\ntype eint88 is bytes32;\\ntype eint96 is bytes32;\\ntype eint104 is bytes32;\\ntype eint112 is bytes32;\\ntype eint120 is bytes32;\\ntype eint128 is bytes32;\\ntype eint136 is bytes32;\\ntype eint144 is bytes32;\\ntype eint152 is bytes32;\\ntype eint160 is bytes32;\\ntype eint168 is bytes32;\\ntype eint176 is bytes32;\\ntype eint184 is bytes32;\\ntype eint192 is bytes32;\\ntype eint200 is bytes32;\\ntype eint208 is bytes32;\\ntype eint216 is bytes32;\\ntype eint224 is bytes32;\\ntype eint232 is bytes32;\\ntype eint240 is bytes32;\\ntype eint248 is bytes32;\\ntype eint256 is bytes32;\\n\\ntype eaddress is bytes32;\\n\\ntype ebytes1 is bytes32;\\ntype ebytes2 is bytes32;\\ntype ebytes3 is bytes32;\\ntype ebytes4 is bytes32;\\ntype ebytes5 is bytes32;\\ntype ebytes6 is bytes32;\\ntype ebytes7 is bytes32;\\ntype ebytes8 is bytes32;\\ntype ebytes9 is bytes32;\\ntype ebytes10 is bytes32;\\ntype ebytes11 is bytes32;\\ntype ebytes12 is bytes32;\\ntype ebytes13 is bytes32;\\ntype ebytes14 is bytes32;\\ntype ebytes15 is bytes32;\\ntype ebytes16 is bytes32;\\ntype ebytes17 is bytes32;\\ntype ebytes18 is bytes32;\\ntype ebytes19 is bytes32;\\ntype ebytes20 is bytes32;\\ntype ebytes21 is bytes32;\\ntype ebytes22 is bytes32;\\ntype ebytes23 is bytes32;\\ntype ebytes24 is bytes32;\\ntype ebytes25 is bytes32;\\ntype ebytes26 is bytes32;\\ntype ebytes27 is bytes32;\\ntype ebytes28 is bytes32;\\ntype ebytes29 is bytes32;\\ntype ebytes30 is bytes32;\\ntype ebytes31 is bytes32;\\ntype ebytes32 is bytes32;\\n\\ntype externalEbool is bytes32;\\n\\ntype externalEuint8 is bytes32;\\ntype externalEuint16 is bytes32;\\ntype externalEuint24 is bytes32;\\ntype externalEuint32 is bytes32;\\ntype externalEuint40 is bytes32;\\ntype externalEuint48 is bytes32;\\ntype externalEuint56 is bytes32;\\ntype externalEuint64 is bytes32;\\ntype externalEuint72 is bytes32;\\ntype externalEuint80 is bytes32;\\ntype externalEuint88 is bytes32;\\ntype externalEuint96 is bytes32;\\ntype externalEuint104 is bytes32;\\ntype externalEuint112 is bytes32;\\ntype externalEuint120 is bytes32;\\ntype externalEuint128 is bytes32;\\ntype externalEuint136 is bytes32;\\ntype externalEuint144 is bytes32;\\ntype externalEuint152 is bytes32;\\ntype externalEuint160 is bytes32;\\ntype externalEuint168 is bytes32;\\ntype externalEuint176 is bytes32;\\ntype externalEuint184 is bytes32;\\ntype externalEuint192 is bytes32;\\ntype externalEuint200 is bytes32;\\ntype externalEuint208 is bytes32;\\ntype externalEuint216 is bytes32;\\ntype externalEuint224 is bytes32;\\ntype externalEuint232 is bytes32;\\ntype externalEuint240 is bytes32;\\ntype externalEuint248 is bytes32;\\ntype externalEuint256 is bytes32;\\n\\ntype externalEint8 is bytes32;\\ntype externalEint16 is bytes32;\\ntype externalEint24 is bytes32;\\ntype externalEint32 is bytes32;\\ntype externalEint40 is bytes32;\\ntype externalEint48 is bytes32;\\ntype externalEint56 is bytes32;\\ntype externalEint64 is bytes32;\\ntype externalEint72 is bytes32;\\ntype externalEint80 is bytes32;\\ntype externalEint88 is bytes32;\\ntype externalEint96 is bytes32;\\ntype externalEint104 is bytes32;\\ntype externalEint112 is bytes32;\\ntype externalEint120 is bytes32;\\ntype externalEint128 is bytes32;\\ntype externalEint136 is bytes32;\\ntype externalEint144 is bytes32;\\ntype externalEint152 is bytes32;\\ntype externalEint160 is bytes32;\\ntype externalEint168 is bytes32;\\ntype externalEint176 is bytes32;\\ntype externalEint184 is bytes32;\\ntype externalEint192 is bytes32;\\ntype externalEint200 is bytes32;\\ntype externalEint208 is bytes32;\\ntype externalEint216 is bytes32;\\ntype externalEint224 is bytes32;\\ntype externalEint232 is bytes32;\\ntype externalEint240 is bytes32;\\ntype externalEint248 is bytes32;\\ntype externalEint256 is bytes32;\\n\\ntype externalEaddress is bytes32;\\n\\ntype externalEbytes1 is bytes32;\\ntype externalEbytes2 is bytes32;\\ntype externalEbytes3 is bytes32;\\ntype externalEbytes4 is bytes32;\\ntype externalEbytes5 is bytes32;\\ntype externalEbytes6 is bytes32;\\ntype externalEbytes7 is bytes32;\\ntype externalEbytes8 is bytes32;\\ntype externalEbytes9 is bytes32;\\ntype externalEbytes10 is bytes32;\\ntype externalEbytes11 is bytes32;\\ntype externalEbytes12 is bytes32;\\ntype externalEbytes13 is bytes32;\\ntype externalEbytes14 is bytes32;\\ntype externalEbytes15 is bytes32;\\ntype externalEbytes16 is bytes32;\\ntype externalEbytes17 is bytes32;\\ntype externalEbytes18 is bytes32;\\ntype externalEbytes19 is bytes32;\\ntype externalEbytes20 is bytes32;\\ntype externalEbytes21 is bytes32;\\ntype externalEbytes22 is bytes32;\\ntype externalEbytes23 is bytes32;\\ntype externalEbytes24 is bytes32;\\ntype externalEbytes25 is bytes32;\\ntype externalEbytes26 is bytes32;\\ntype externalEbytes27 is bytes32;\\ntype externalEbytes28 is bytes32;\\ntype externalEbytes29 is bytes32;\\ntype externalEbytes30 is bytes32;\\ntype externalEbytes31 is bytes32;\\ntype externalEbytes32 is bytes32;\\n\",\"keccak256\":\"0x5da9799cd5c30067ea946164722197151baee1f2579a76f01874d4fb25df02a3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c060405260016005556001600f553480156200001a575f80fd5b5060405162004e6b38038062004e6b8339810160408190526200003d91620002b7565b33806200006357604051631e4fbdf760e01b81525f600482015260240160405180910390fd5b6200006e816200024c565b5060018055620001ef62000113604080516080810182525f808252602082018190529181018290526060810191909152506040805160808101825273687820221192c5b662b25367f70076a37bc79b6c815273848b0066793bcc60346da1f49049357399b8d5956020820152731364cbbf2cdf5032c47d8226a6f6fbd2afcdacac9181019190915273bc91f3dad1a5f19f8390c400196e58073b6a0bc4606082015290565b80517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60080546001600160a01b03199081166001600160a01b039384161790915560208301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6018054831691841691909117905560408301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6028054831691841691909117905560608301517fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea6038054909216921691909117905550565b7f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d0080546001600160a01b03191673a02cda4ca3a71d7c46997716f4283aa851c288121790556001600160a01b039182166080521660a052620002ed565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80516001600160a01b0381168114620002b2575f80fd5b919050565b5f8060408385031215620002c9575f80fd5b620002d4836200029b565b9150620002e4602084016200029b565b90509250929050565b60805160a051614afa620003715f395f818161078701528181611614015281816116a9015261173d01525f818161043c015281816107d10152818161087501528181610b7101528181610bfa01528181610d8901528181611b6601528181611bbc01528181612297015281816122ec015281816124aa01526125000152614afa5ff3fe608060405234801561000f575f80fd5b5060043610610269575f3560e01c806389a3027111610157578063b1620616116100d2578063c960a32411610088578063f2fde38b1161006e578063f2fde38b1461075a578063f800ece91461076d578063f887ea4014610782575f80fd5b8063c960a32414610716578063e52028d514610738575f80fd5b8063b35876e7116100b8578063b35876e7146106c8578063b9642260146106db578063c750f8fd14610703575f80fd5b8063b162061614610527578063b32c4d8d14610620575f80fd5b80639559c0bd116101275780639bd129691161010d5780639bd12969146104d35780639f4a323e146104f2578063a6c3be1314610505575f80fd5b80639559c0bd146104a95780639ac2a011146104b1575f80fd5b806389a30271146104375780638c2e02de1461045e5780638da5cb5b146104715780638e2de4d314610481575f80fd5b80635947fa25116101e7578063792f8a0c116101b757806380d6664c1161019d57806380d6664c146103fe57806383589fde14610411578063882da1f114610424575f80fd5b8063792f8a0c146103ab5780637dc5ad37146103eb575f80fd5b80635947fa25146103685780635f8d26b2146103875780636579c99214610390578063715018a6146103a3575f80fd5b80631e3dd18b1161023c578063391a9e1111610222578063391a9e11146103235780633dc1d233146103365780634726a16014610355575f80fd5b80631e3dd18b146102ea5780632e1a7d4d14610310575f80fd5b80630311b02f1461026d5780631128f2221461029557806312ac9b46146102c25780631e1bff3f146102d5575b5f80fd5b61028061027b366004613ea3565b6107a9565b60405190151581526020015b60405180910390f35b6102b46102a3366004613ecb565b60106020525f908152604090205481565b60405190815260200161028c565b6102806102d0366004613ea3565b610847565b6102e86102e3366004613eef565b6108a6565b005b6102fd6102f8366004613ecb565b61090c565b60405161028c9796959493929190613f67565b6102e861031e366004613ecb565b610a84565b6102b4610331366004613fe3565b610b6b565b6102b4610344366004613ecb565b60126020525f908152604090205481565b6102806103633660046141f8565b611064565b6102b4610376366004613ecb565b600a6020525f908152604090205481565b6102b460055481565b61028061039e366004614244565b6112f2565b6102e86114c1565b6103d36103b9366004613ecb565b600b6020525f90815260409020546001600160a01b031681565b6040516001600160a01b03909116815260200161028c565b6102806103f93660046141f8565b6114d4565b6102e861040c366004613ecb565b61193d565b6102e861041f366004613ecb565b611ab1565b6102e86104323660046142af565b611b5c565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6102e861046c366004613ecb565b6121fa565b5f546001600160a01b03166103d3565b6103d361048f366004613ecb565b60076020525f90815260409020546001600160a01b031681565b6102b4600a81565b6102806104bf366004614363565b600e6020525f908152604090205460ff1681565b6102b46104e1366004613ecb565b600d6020525f908152604090205481565b6102e861050036600461437c565b61242c565b610280610513366004613ecb565b60096020525f908152604090205460ff1681565b61060e610535366004613ecb565b600660208181525f92835260409283902080548451808601865260018301546001600160a01b0390811682526002840154811682860152865160a081018852600385015467ffffffffffffffff1681526004850154818701526005850154818901529584015460608088019190915260078501546080808901919091528851908101895260088601548152600986015481880152600a860154818a0152600b86015491810191909152600c8501548851808a01909952600d8601548952600e9095015495880195909552909116949093929160ff169086565b60405161028c969594939291906143d5565b61068361062e366004613ecb565b60116020525f90815260409020805460018201546002830154600484015460059094015492936001600160a01b0392831693929091169167ffffffffffffffff81169068010000000000000000900460ff1686565b604080519687526001600160a01b0395861660208801529390941692850192909252606084015267ffffffffffffffff166080830152151560a082015260c00161028c565b6102e86106d6366004613ecb565b612ae5565b6103d36106e9366004613ecb565b60086020525f90815260409020546001600160a01b031681565b610280610711366004614244565b612b8a565b610280610724366004613ecb565b600c6020525f908152604090205460ff1681565b610280610746366004613ecb565b60026020525f908152604090205460ff1681565b6102e8610768366004614363565b612ec7565b610775612f01565b60405161028c9190614494565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b60405163a9059cbb60e01b81526001600160a01b038381166004830152602482018390525f917f00000000000000000000000000000000000000000000000000000000000000009091169063a9059cbb906044015b6020604051808303815f875af115801561081a573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061083e919061456e565b90505b92915050565b6040516323b872dd60e01b81526001600160a01b038381166004830152306024830152604482018390525f917f0000000000000000000000000000000000000000000000000000000000000000909116906323b872dd906064016107fe565b6108ae6130e0565b6001600160a01b0382165f818152600e6020908152604091829020805460ff191685151590811790915591519182527f278b09622564dd3991fe7744514513d64ea2c8ed2b2b9ec1150ad964fde80a99910160405180910390a25050565b6004818154811061091b575f80fd5b5f918252602090912060059091020180546001820180546001600160a01b0390921693509061094990614589565b80601f016020809104026020016040519081016040528092919081815260200182805461097590614589565b80156109c05780601f10610997576101008083540402835291602001916109c0565b820191905f5260205f20905b8154815290600101906020018083116109a357829003601f168201915b505050506002830154600384018054939460ff8316946101009093046001600160a01b03169350916109f190614589565b80601f0160208091040260200160405190810160405280929190818152602001828054610a1d90614589565b8015610a685780601f10610a3f57610100808354040283529160200191610a68565b820191905f5260205f20905b815481529060010190602001808311610a4b57829003601f168201915b5050506004909301549192505060ff8082169161010090041687565b5f81815260066020526040902080546001600160a01b0316610ac157604051633582fa3760e11b8152600481018390526024015b60405180910390fd5b80546001600160a01b03163314610aff57805460405163833ce3c560e01b81523360048201526001600160a01b039091166024820152604401610ab8565b6040805160018082528183019092525f916020808301908036833701905050600b830154909150815f81518110610b3857610b386145c1565b60209081029190910101525f610b5582630239350b60e51b61310c565b5f90815260136020526040902093909355505050565b5f60025f7f00000000000000000000000000000000000000000000000000000000000000008b604051602001610bb79291906001600160a01b0392831681529116602082015260400190565b60408051601f198184030181529181528151602092830120835290820192909252015f205460ff16610c2f576040516368bd6d4960e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301528a166024820152604401610ab8565b5f610c6f8685858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061311892505050565b90505f610cb18686868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061311892505050565b90505f610cf38a87878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061311892505050565b90505f610d358a88888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061311892505050565b600580549192505f610d46836145e9565b9190505594505f60065f8781526020019081526020015f20905033815f015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055507f0000000000000000000000000000000000000000000000000000000000000000816001015f015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055508d816001016001015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055508c816003015f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550828160030160010181905550848160080160020181905550838160030160030181905550610e555f613125565b6007820155610e635f613125565b600b820155610e715f613125565b60058201556008810182905560098101829055600c8101805460ff19169055600e8101869055600a810154610ea59061313b565b506006810154610eb49061313b565b506007810154610ec39061313b565b50600b810154610ed29061313b565b506004810154610ee19061313b565b506008810154610ef09061313b565b506005810154610eff9061313b565b506009810154610f0e9061313b565b50600a810154610f1e903361314a565b506006810154610f2e903361314a565b506007810154610f3e903361314a565b50600b810154610f4e903361314a565b506004810154610f5e903361314a565b506008810154610f6e903361314a565b506005810154610f7e903361314a565b506009810154610f8e903361314a565b506040805160018082528183019092525f916020808301908036833701905050905082815f81518110610fc357610fc36145c1565b60209081029190910101525f610fe08263c750f8fd60e01b61310c565b5f81815260076020908152604080832080546001600160a01b03199081163390811790925560088452828520805490911630179055600a9092528083208c9055600d870184905551929350918a917f6b67a01eb500680a90226d64ad9239c6dc9c95b64ea6a8d9a3b5b94197b4658591a35050505050505098975050505050505050565b5f838152601360205260408120548082036110955760405163261c57d160e21b815260048101869052602401610ab8565b61109f858461315c565b5f818152600660208181526040808420815160c08101835281546001600160a01b0390811682528351808501855260018401548216815260028401549091168186015281850152825160a081018452600383015467ffffffffffffffff16815260048084015482870152600584015482860152958301546060808301919091526007840154608080840191909152838601929092528451808301865260088501548152600985015496810196909652600a84015494860194909452600b8301548585015292810193909352600c810154929390929184019160ff169081111561118a5761118a6143ad565b600481111561119b5761119b6143ad565b8152604080518082018252600d8401548152600e90930154602080850191909152918201929092528281015101518251915163a9059cbb60e01b81526001600160a01b03928316600482015260248101899052929350919082169063a9059cbb906044016020604051808303815f875af1925050508015611239575060408051601f3d908101601f191682019092526112369181019061456e565b60015b6112a757611245614601565b806308c379a003611281575061125961461a565b806112645750611283565b818160405163c29d9e4760e01b8152600401610ab89291906146a3565b505b60405163fa347b2160e01b81526001600160a01b0382166004820152602401610ab8565b806112e25782516040516307a1d48760e01b81526001600160a01b038085166004830152909116602482015260448101889052606401610ab8565b50600193505050505b9392505050565b5f838152600c602052604081205460ff161561132457604051636c0a991f60e01b815260048101859052602401610ab8565b5f848152600b60205260409020546001600160a01b0316611345858461315c565b5f858152600c60209081526040808320805460ff19166001179055600d82528083205483526006909152908190209051630311b02f60e01b81526001600160a01b038316600482015267ffffffffffffffff86166024820181905291903090630311b02f906044016020604051808303815f875af19250505080156113e7575060408051601f3d908101601f191682019092526113e49181019061456e565b60015b611468576113f3614601565b806308c379a003611435575061140761461a565b806114125750611437565b5f600d830155604051631033c5ff60e31b8152610ab890859083906004016146a3565b505b5f600d820155604051630c0ab95b60e21b81526001600160a01b038416600482015260248101839052604401610ab8565b8061149e575f600d8301556040516357b9d85960e11b81526001600160a01b038516600482015260248101849052604401610ab8565b50600c8101805460ff191660041790555f600d9091015550600191506112eb9050565b6114c96130e0565b6114d25f6131c3565b565b5f8381526012602052604081205480820361150557604051636611701960e11b815260048101869052602401610ab8565b61150f858461315c565b5f818152601160205260409020600581015468010000000000000000900460ff161561155157604051632dd7dfe360e11b815260048101839052602401610ab8565b845f8190036115765760405163967d723360e01b815260048101849052602401610ab8565b6040805160028082526060820183525f92602083019080368337505050600184015481519192506001600160a01b03169082905f906115b7576115b76145c1565b6001600160a01b03928316602091820292909201015260028401548251911690829060019081106115ea576115ea6145c1565b6001600160a01b039283166020918202929092010152600184015460405163095ea7b360e01b81527f0000000000000000000000000000000000000000000000000000000000000000831660048201525f602482015291169063095ea7b3906044016020604051808303815f875af1158015611668573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061168c919061456e565b50600183015460405163095ea7b360e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018590529091169063095ea7b3906044016020604051808303815f875af11580156116ff573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611723919061456e565b506040516338ed173960e01b81525f906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906338ed17399061177a90869085908790309042906004016146c4565b5f604051808303815f875af1158015611795573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526117bc9190810190614735565b90505f81600183516117ce91906147c1565b815181106117de576117de6145c1565b602002602001015190505f6117f282613125565b90506117fd8161313b565b5060038601545f5b818110156118d0575f886006018281548110611823576118236145c1565b905f5260205f20015490505f6118398583613212565b90506118448161313b565b505f611850828b613240565b90505f60065f8d600301878154811061186b5761186b6145c1565b905f5260205f20015481526020019081526020015f209050611894816008016003015483613266565b600b82018190556118a49061313b565b50600b81015481546118bf91906001600160a01b031661314a565b505060019093019250611805915050565b5060058701805468ff0000000000000000191668010000000000000000179055604080518781526020810185905289917f2403003b183ff811dedab647749b7525f94e39ff05e4a7b4f02743c21b6c1622910160405180910390a25060019b9a5050505050505050505050565b5f81815260066020526040902080546001600160a01b0316331461198857805460405163833ce3c560e01b81523360048201526001600160a01b039091166024820152604401610ab8565b6004600c82015460ff1660048111156119a3576119a36143ad565b14806119c757506003600c82015460ff1660048111156119c5576119c56143ad565b145b156119f157600c810154604051630163d0b760e41b8152610ab89160ff16906001906004016147d4565b6040805160018082528183019092525f9160208083019080368337019050506009830154909150815f81518110611a2a57611a2a6145c1565b60209081029190910101525f611a47826332bce4c960e11b61310c565b5f818152600b6020908152604080832080546001600160a01b03191633179055600c8252808320805460ff19169055600d9091528082208790555191925085917f09f4c2fd13cc57768b21af5847536074d3fab1d1dfe1e382d9259c516945ea6d9190a250505050565b5f81815260066020526040902080546001600160a01b03163314611afc57805460405163833ce3c560e01b81523360048201526001600160a01b039091166024820152604401610ab8565b6001600c82015460ff166004811115611b1757611b176143ad565b14611b4157600c810154604051630163d0b760e41b8152610ab89160ff16906001906004016147d4565b600c810180546002919060ff19166001835b02179055505050565b611b646130e0565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316876001600160a01b031614611be957604051638a26cfc960e01b81526001600160a01b0380891660048301527f0000000000000000000000000000000000000000000000000000000000000000166024820152604401610ab8565b604080516001600160a01b03808a1660208301528616918101919091525f9060600160408051808303601f1901815291815281516020928301205f81815260029093529120805460ff19168415801591909117909155909150611dde575f8181526003602052604090205415611c74576040516249063560e61b815260048101829052602401610ab8565b6040805160e0810182526001600160a01b038a81168252602082018a815260ff8a81169484019490945288821660608401526080830188905292861660a083015284151560c0830152600480546001810182555f9190915282517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b600590920291820180546001600160a01b031916919093161782559251919290917f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19c90910190611d3f908261483b565b50604082015160028201805460608501516001600160a01b03166101000274ffffffffffffffffffffffffffffffffffffffffff1990911660ff9093169290921791909117905560808201516003820190611d9a908261483b565b5060a08201516004918201805460c09094015115156101000261ffff1990941660ff9092169190911792909217909155545f828152600360205260409020556121a1565b5f8181526003602052604081205490819003611e1057604051631fdc01bd60e21b815260048101839052602401610ab8565b600454818114612114575f6004611e286001846147c1565b81548110611e3857611e386145c1565b5f9182526020918290206040805160e0810190915260059092020180546001600160a01b031682526001810180549293919291840191611e7790614589565b80601f0160208091040260200160405190810160405280929190818152602001828054611ea390614589565b8015611eee5780601f10611ec557610100808354040283529160200191611eee565b820191905f5260205f20905b815481529060010190602001808311611ed157829003601f168201915b5050509183525050600282015460ff8116602083015261010090046001600160a01b03166040820152600382018054606090920191611f2c90614589565b80601f0160208091040260200160405190810160405280929190818152602001828054611f5890614589565b8015611fa35780601f10611f7a57610100808354040283529160200191611fa3565b820191905f5260205f20905b815481529060010190602001808311611f8657829003601f168201915b505050918352505060049182015460ff80821660208401526101009091041615156040909101529091508190611fda6001866147c1565b81548110611fea57611fea6145c1565b5f91825260209182902083516005929092020180546001600160a01b0319166001600160a01b0390921691909117815590820151600182019061202d908261483b565b50604082015160028201805460608501516001600160a01b03166101000274ffffffffffffffffffffffffffffffffffffffffff1990911660ff9093169290921791909117905560808201516003820190612088908261483b565b5060a08201516004909101805460c09093015115156101000261ffff1990931660ff909216919091179190911790558051606082015160405185926003925f926120eb9291906020016001600160a01b0392831681529116602082015260400190565b6040516020818303038152906040528051906020012081526020019081526020015f2081905550505b6004805480612125576121256148fb565b5f8281526020812060055f199093019283020180546001600160a01b0319168155906121546001830182613dfc565b60028201805474ffffffffffffffffffffffffffffffffffffffffff19169055612181600383015f613dfc565b50600401805461ffff19169055905550505f818152600360205260408120555b846001600160a01b0316886001600160a01b03167fa0be238839c65552a544da5e66b7a224fe553eccb19681bc2ddd043f4ec863ce846040516121e8911515815260200190565b60405180910390a35050505050505050565b612202613294565b5f81815260066020526040812090600c82015460ff166004811115612229576122296143ad565b1461225257600c810154604051630163d0b760e41b8152610ab89160ff16905f906004016147d4565b80546001600160a01b0316331461229057805460405163833ce3c560e01b81523360048201526001600160a01b039091166024820152604401610ab8565b60018101547f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161461231b576001810154604051638a26cfc960e01b81526001600160a01b0391821660048201527f00000000000000000000000000000000000000000000000000000000000000009091166024820152604401610ab8565b600d8101541561234757600d810154604051633cbec87360e11b81526004810191909152602401610ab8565b6040805160018082528183019092525f9160208083019080368337019050506008830154909150815f81518110612380576123806145c1565b60209081029190910101525f61239d8263c750f8fd60e01b61310c565b5f81815260076020908152604080832080546001600160a01b03199081163317909155600880845282852080549092163017909155600a835292819020889055600d870184905591860154915191825291925085917f58f5b348d768706eb06a6b936c1693225c21d718ba68427539112fc61c4c824f910160405180910390a250505061242960018055565b50565b604080516001600160a01b0380851660208301528316918101919091525f9060600160408051601f1981840301815291815281516020928301205f818152600290935291205490915060ff166124a8576040516368bd6d4960e01b81526001600160a01b03808516600483015283166024820152604401610ab8565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316836001600160a01b03161461252d57604051638a26cfc960e01b81526001600160a01b0380851660048301527f0000000000000000000000000000000000000000000000000000000000000000166024820152604401610ab8565b425f61253882613125565b60408051600a80825261016082019092529192505f919060208201610140803683370190505090505f8061256b5f613125565b60408051600a80825261016082019092529192505f919060208201610140803683375050505f88815260106020526040902054909150805b600554811080156125b45750600a85105b156127c7575f8181526006602052604090206001600c82015460ff1660048111156125e1576125e16143ad565b146125ec57506127b5565b60018101546001600160a01b038d811691161461260957506127b5565b60028101546001600160a01b038c811691161461262657506127b5565b60038101545f9061264b908a906126469067ffffffffffffffff16613125565b6132be565b90505f612666836003016004015484600301600301546132ec565b90505f612673838361331a565b90505f61268e856008016001015486600801600201546132ec565b90505f6126aa8287600801600101548860080160020154613348565b90505f6126c084836126bb5f613125565b613348565b90506126cc8b82613266565b9a506126df87600801600101548261335c565b600988018190556126ef9061313b565b506009870154875461270a91906001600160a01b031661314a565b505f6127238561271a6001613125565b6126bb5f613125565b9050612736886003016004015482613266565b600789018190556127469061313b565b506007880154885461276191906001600160a01b031661314a565b50888e8e81518110612775576127756145c1565b602002602001018181525050818b8e81518110612794576127946145c1565b60209081029190910101528c6127a9816145e9565b9d505050505050505050505b806127bf816145e9565b9150506125a3565b506127d2848261490f565b5f898152601060205260409020819055600554116127f9575f888152601060205260408120555b835f0361281c576040516368c7f07560e11b815260048101899052602401610ab8565b5f8467ffffffffffffffff81111561283657612836614094565b60405190808252806020026020018201604052801561285f578160200160208202803683370190505b5090505f8567ffffffffffffffff81111561287c5761287c614094565b6040519080825280602002602001820160405280156128a5578160200160208202803683370190505b5090505f5b8681101561294d578781815181106128c4576128c46145c1565b60200260200101518382815181106128de576128de6145c1565b6020026020010181815250508481815181106128fc576128fc6145c1565b6020026020010151828281518110612916576129166145c1565b602002602001018181525050612944828281518110612937576129376145c1565b602002602001015161313b565b506001016128aa565b50600f80545f918261295e836145e9565b9190505590505f60115f8381526020019081526020015f20905081815f01819055508d816001015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055508c816002015f6101000a8154816001600160a01b0302191690836001600160a01b03160217905550838160030190805190602001906129e8929190613e33565b5082516129fe9060068301906020860190613e33565b506004810187905560058101805468ffffffffffffffffff191667ffffffffffffffff8d161790556040805160018082528183019092525f916020808301908036833701905050905087815f81518110612a5a57612a5a6145c1565b60209081029190910101525f612a7782637dc5ad3760e01b61310c565b90508360125f8381526020019081526020015f20819055508e6001600160a01b0316847f4e8b671325df0fa1bd467eba25b6137a2055be9cd84a626c78581cfb12a94f5e8c604051612acb91815260200190565b60405180910390a350505050505050505050505050505050565b5f81815260066020526040902080546001600160a01b03163314612b3057805460405163833ce3c560e01b81523360048201526001600160a01b039091166024820152604401610ab8565b6002600c82015460ff166004811115612b4b57612b4b6143ad565b14612b7557600c810154604051630163d0b760e41b8152610ab89160ff16906002906004016147d4565b600c810180546001919060ff19168280611b53565b5f8381526009602052604081205460ff1615612bbc576040516301c4fa3d60e51b815260048101859052602401610ab8565b5f848152600760209081526040808320546008909252909120546001600160a01b039182169116612bed868561315c565b5f868152600960209081526040808320805460ff19166001179055600a825280832054835260069091529020600d81015467ffffffffffffffff871691908814612c5357600d810154604051633cbec87360e11b81526004810191909152602401610ab8565b5f600d8201556040516309564da360e11b81526001600160a01b03851660048201526024810183905230906312ac9b46906044016020604051808303815f875af1925050508015612cc1575060408051601f3d908101601f19168201909252612cbe9181019061456e565b60015b612dd857612ccd614601565b806308c379a003612d475750612ce161461a565b80612cec5750612d49565b836001600160a01b0316856001600160a01b03168a7faa7c343a6dcb357305f5cca178d1e5bcf74f1cece577e2f4ab98e7fc9759ba898685604051612d32929190614922565b60405180910390a45f955050505050506112eb565b505b826001600160a01b0316846001600160a01b0316897faa7c343a6dcb357305f5cca178d1e5bcf74f1cece577e2f4ab98e7fc9759ba8985604051612dc49181526040602082018190526015908201527f546f6b656e207472616e73666572206661696c65640000000000000000000000606082015260800190565b60405180910390a45f9450505050506112eb565b8015612e4057600c8201805460ff191660011790556040518381526001600160a01b0380861691908716908b907ff1b289f30d1499938643326e8dad1060509095ff97a300b4a36a9f0771c29e949060200160405180910390a46001955050505050506112eb565b836001600160a01b0316856001600160a01b03168a7faa7c343a6dcb357305f5cca178d1e5bcf74f1cece577e2f4ab98e7fc9759ba8986604051612d32918152604060208201819052601d908201527f546f6b656e207472616e736665722072657475726e65642066616c7365000000606082015260800190565b50505050509392505050565b612ecf6130e0565b6001600160a01b038116612ef857604051631e4fbdf760e01b81525f6004820152602401610ab8565b612429816131c3565b60606004805480602002602001604051908101604052809291908181526020015f905b828210156130d7575f8481526020908190206040805160e081019091526005850290910180546001600160a01b031682526001810180549293919291840191612f6c90614589565b80601f0160208091040260200160405190810160405280929190818152602001828054612f9890614589565b8015612fe35780601f10612fba57610100808354040283529160200191612fe3565b820191905f5260205f20905b815481529060010190602001808311612fc657829003601f168201915b5050509183525050600282015460ff8116602083015261010090046001600160a01b0316604082015260038201805460609092019161302190614589565b80601f016020809104026020016040519081016040528092919081815260200182805461304d90614589565b80156130985780601f1061306f57610100808354040283529160200191613098565b820191905f5260205f20905b81548152906001019060200180831161307b57829003601f168201915b50505091835250506004919091015460ff8082166020808501919091526101009092041615156040909201919091529082526001929092019101612f24565b50505050905090565b5f546001600160a01b031633146114d25760405163118cdaa760e01b8152336004820152602401610ab8565b5f61083e83835f61338a565b5f61083e838360056134c3565b5f6108418267ffffffffffffffff1660056135b1565b5f6131468230613640565b5090565b5f6131558383613640565b5090919050565b5f613166836136b6565b90505f6131738284613787565b9050806131935760405163cf6c44e960e01b815260040160405180910390fd5b60405184907f1af0453083661051f6e56e5c070792320652e612154bf9af8637bb1e7655b99d905f90a250505050565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f82613224576132215f613125565b92505b81613235576132325f613125565b91505b61083e83835f61388f565b5f826132525761324f5f613125565b92505b61083e8367ffffffffffffffff841661394c565b5f82613278576132755f613125565b92505b81613289576132865f613125565b91505b61083e83835f6139f2565b6002600154036132b757604051633ee5aeb560e01b815260040160405180910390fd5b6002600155565b5f826132d0576132cd5f613125565b92505b816132e1576132de5f613125565b91505b61083e83835f613a69565b5f826132fe576132fb5f613125565b92505b8161330f5761330c5f613125565b91505b61083e83835f613ae0565b5f8261332c576133295f613b57565b92505b8161333d5761333a5f613b57565b91505b61083e83835f613b72565b5f613354848484613be9565b949350505050565b5f8261336e5761336b5f613125565b92505b8161337f5761337c5f613125565b91505b61083e83835f613c45565b7f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d01545f80516020614aae8339815191528054604051637d6e912360e11b81527f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d0092916001600160a01b03169063fadd22469061340a908990600401614974565b5f604051808303815f87803b158015613421575f80fd5b505af1158015613433573d5f803e3d5ffd5b50508354604051633263b83b60e01b81526001600160a01b039091169250633263b83b9150869061346c9087908b908b90600401614986565b5f604051808303818588803b158015613483575f80fd5b505af1158015613495573d5f803e3d5ffd5b50505050506134a48387613cbc565b600182018054905f6134b5836145e9565b919050555050509392505050565b5f80516020614ace8339815191525460405163196d0b9b60e01b81525f915f80516020614aae833981519152916001600160a01b039091169063196d0b9b906135169088903390899089906004016149c7565b6020604051808303815f875af1158015613532573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061355691906149fd565b8154604051630f8e573b60e21b8152600481018390523360248201529193506001600160a01b031690633e395cec906044015f604051808303815f87803b15801561359f575f80fd5b505af1158015612ebb573d5f803e3d5ffd5b5f80516020614ace83398151915254604051639cd07acb60e01b81525f915f80516020614aae833981519152916001600160a01b0390911690639cd07acb906136009087908790600401614a14565b6020604051808303815f875af115801561361c573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061335491906149fd565b5f5f80516020614aae8339815191528054604051635ca4b5b160e11b8152600481018690526001600160a01b03858116602483015292935091169063b9496b62906044015f604051808303815f87803b15801561369b575f80fd5b505af11580156136ad573d5f803e3d5ffd5b50505050505050565b5f8181527f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d0260205260408120546060917f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d009190036137275760405163d66ca67560e01b815260040160405180910390fd5b5f8381526002820160209081526040918290208054835181840281018401909452808452909183018282801561377a57602002820191905f5260205f20905b815481526020019060010190808311613766575b5050505050915050919050565b5f60248161379485613d4f565b90505f8167ffffffffffffffff8111156137b0576137b0614094565b6040519080825280601f01601f1916602001820160405280156137da576020820181803683370190505b509050818360208301377fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60254604051632c027b1360e21b81525f80516020614aae833981519152916001600160a01b03169063b009ec4c90613844908a9086908b90600401614a28565b6020604051808303815f875af1158015613860573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190613884919061456e565b979650505050505050565b5f8082156138a25750600160f81b6138a5565b505f5b5f80516020614ace83398151915254604051630afe14ad60e31b815260048101879052602481018690526001600160f81b0319831660448201525f80516020614aae833981519152916001600160a01b0316906357f0a568906064015b6020604051808303815f875af115801561391e573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061394291906149fd565b9695505050505050565b5f80516020614ace83398151915254604051635a53accb60e01b81526004810184905260248101839052600160f81b604482018190525f9290915f80516020614aae833981519152916001600160a01b031690635a53accb906064015b6020604051808303815f875af11580156139c5573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906139e991906149fd565b95945050505050565b5f808215613a055750600160f81b613a08565b505f5b5f80516020614ace8339815191525460405163022f65e760e31b815260048101879052602481018690526001600160f81b0319831660448201525f80516020614aae833981519152916001600160a01b03169063117b2f3890606401613902565b5f808215613a7c5750600160f81b613a7f565b505f5b5f80516020614ace833981519152546040516385362ee760e01b815260048101879052602481018690526001600160f81b0319831660448201525f80516020614aae833981519152916001600160a01b0316906385362ee790606401613902565b5f808215613af35750600160f81b613af6565b505f5b5f80516020614ace83398151915254604051637210768160e01b815260048101879052602481018690526001600160f81b0319831660448201525f80516020614aae833981519152916001600160a01b031690637210768190606401613902565b5f61084182613b66575f613b69565b60015b60ff165f6135b1565b5f808215613b855750600160f81b613b88565b505f5b5f80516020614ace8339815191525460405163d99882d560e01b815260048101879052602481018690526001600160f81b0319831660448201525f80516020614aae833981519152916001600160a01b03169063d99882d590606401613902565b5f80516020614ace83398151915254604051637702dcff60e01b81526004810185905260248101849052604481018390525f915f80516020614aae833981519152916001600160a01b0390911690637702dcff906064016139a9565b5f808215613c585750600160f81b613c5b565b505f5b5f80516020614ace833981519152546040516303056db360e31b815260048101879052602481018690526001600160f81b0319831660448201525f80516020614aae833981519152916001600160a01b03169063182b6d9890606401613902565b5f8281527f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d0260205260409020547f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d009015613d2957604051633f06d22b60e01b815260040160405180910390fd5b5f83815260028201602090815260409091208351613d4992850190613e33565b50505050565b80515f9081805b82811015613df0575f858281518110613d7157613d716145c1565b6020026020010151601e60208110613d8b57613d8b6145c1565b1a6053811115613d9d57613d9d6143ad565b90506009816053811115613db357613db36143ad565b60ff161015613dce57613dc760208461490f565b9250613de7565b60405163ce54a8d160e01b815260040160405180910390fd5b50600101613d56565b5061335460208261490f565b508054613e0890614589565b5f825580601f10613e17575050565b601f0160209004905f5260205f20908101906124299190613e74565b828054828255905f5260205f20908101928215613e6c579160200282015b82811115613e6c578251825591602001919060010190613e51565b506131469291505b5b80821115613146575f8155600101613e75565b80356001600160a01b0381168114613e9e575f80fd5b919050565b5f8060408385031215613eb4575f80fd5b613ebd83613e88565b946020939093013593505050565b5f60208284031215613edb575f80fd5b5035919050565b8015158114612429575f80fd5b5f8060408385031215613f00575f80fd5b613f0983613e88565b91506020830135613f1981613ee2565b809150509250929050565b5f81518084525f5b81811015613f4857602081850181015186830182015201613f2c565b505f602082860101526020601f19601f83011685010191505092915050565b5f6001600160a01b03808a16835260e06020840152613f8960e084018a613f24565b60ff8916604085015281881660608501528381036080850152613fac8188613f24565b60ff9690961660a085015250505090151560c09091015295945050505050565b803567ffffffffffffffff81168114613e9e575f80fd5b5f805f805f805f8060e0898b031215613ffa575f80fd5b61400389613e88565b975061401160208a01613fcc565b965060408901359550606089013594506080890135935060a0890135925060c089013567ffffffffffffffff80821115614049575f80fd5b818b0191508b601f83011261405c575f80fd5b81358181111561406a575f80fd5b8c602082850101111561407b575f80fd5b6020830194508093505050509295985092959890939650565b634e487b7160e01b5f52604160045260245ffd5b601f8201601f1916810167ffffffffffffffff811182821017156140ce576140ce614094565b6040525050565b5f67ffffffffffffffff8211156140ee576140ee614094565b5060051b60200190565b5f67ffffffffffffffff83111561411157614111614094565b604051614128601f8501601f1916602001826140a8565b80915083815284848401111561413c575f80fd5b838360208301375f60208583010152509392505050565b5f82601f830112614162575f80fd5b8135602061416f826140d5565b6040805161417d83826140a8565b84815260059490941b860183019383810192508785111561419c575f80fd5b8387015b858110156141ec57803567ffffffffffffffff8111156141be575f80fd5b8801603f81018a136141ce575f80fd5b6141de8a878301358684016140f8565b8552509284019284016141a0565b50979650505050505050565b5f805f6060848603121561420a575f80fd5b8335925060208401359150604084013567ffffffffffffffff81111561422e575f80fd5b61423a86828701614153565b9150509250925092565b5f805f60608486031215614256575f80fd5b8335925061426660208501613fcc565b9150604084013567ffffffffffffffff81111561422e575f80fd5b5f82601f830112614290575f80fd5b61083e838335602085016140f8565b803560ff81168114613e9e575f80fd5b5f805f805f805f60e0888a0312156142c5575f80fd5b6142ce88613e88565b9650602088013567ffffffffffffffff808211156142ea575f80fd5b6142f68b838c01614281565b975061430460408b0161429f565b965061431260608b01613e88565b955060808a0135915080821115614327575f80fd5b506143348a828b01614281565b93505061434360a0890161429f565b915060c088013561435381613ee2565b8091505092959891949750929550565b5f60208284031215614373575f80fd5b61083e82613e88565b5f806040838503121561438d575f80fd5b61439683613e88565b91506143a460208401613e88565b90509250929050565b634e487b7160e01b5f52602160045260245ffd5b600581106143d1576143d16143ad565b9052565b5f6101e0820190506001600160a01b0380891683528088511660208401528060208901511660408401525067ffffffffffffffff865116606083015260208601516080830152604086015160a0830152606086015160c0830152608086015160e0830152614468610100830186805182526020810151602083015260408101516040830152606081015160608301525050565b6144766101808301856143c1565b82516101a083015260208301516101c0830152979650505050505050565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b8381101561456057603f19898403018552815160e06001600160a01b0380835116865289830151828b8801526144f383880182613f24565b92505060ff8984015116898701526060818185015116818801525050608080830151868303828801526145268382613f24565b9250505060a08083015161453e8288018260ff169052565b505060c0918201511515949091019390935293860193908601906001016144bb565b509098975050505050505050565b5f6020828403121561457e575f80fd5b81516112eb81613ee2565b600181811c9082168061459d57607f821691505b6020821081036145bb57634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b5f600182016145fa576145fa6145d5565b5060010190565b5f60033d11156146175760045f803e505f5160e01c5b90565b5f60443d10156146275790565b6040516003193d81016004833e81513d67ffffffffffffffff816024840111818411171561465757505050505090565b828501915081518181111561466f5750505050505090565b843d87010160208285010111156146895750505050505090565b614698602082860101876140a8565b509095945050505050565b6001600160a01b0383168152604060208201525f6133546040830184613f24565b5f60a08201878352602087602085015260a0604085015281875180845260c0860191506020890193505f5b818110156147145784516001600160a01b0316835293830193918301916001016146ef565b50506001600160a01b03969096166060850152505050608001529392505050565b5f6020808385031215614746575f80fd5b825167ffffffffffffffff81111561475c575f80fd5b8301601f8101851361476c575f80fd5b8051614777816140d5565b60405161478482826140a8565b82815260059290921b83018401918481019150878311156147a3575f80fd5b928401925b82841015613884578351825292840192908401906147a8565b81810381811115610841576108416145d5565b604081016147e282856143c1565b6112eb60208301846143c1565b601f82111561483657805f5260205f20601f840160051c810160208510156148145750805b601f840160051c820191505b81811015614833575f8155600101614820565b50505b505050565b815167ffffffffffffffff81111561485557614855614094565b614869816148638454614589565b846147ef565b602080601f83116001811461489c575f84156148855750858301515b5f19600386901b1c1916600185901b1785556148f3565b5f85815260208120601f198616915b828110156148ca578886015182559484019460019091019084016148ab565b50858210156148e757878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b634e487b7160e01b5f52603160045260245ffd5b80820180821115610841576108416145d5565b828152604060208201525f6133546040830184613f24565b5f815180845260208085019450602084015f5b838110156149695781518752958201959082019060010161494d565b509495945050505050565b602081525f61083e602083018461493a565b838152606060208201525f61499e606083018561493a565b905063ffffffff60e01b83166040830152949350505050565b605481106143d1576143d16143ad565b8481526001600160a01b0384166020820152608060408201525f6149ee6080830185613f24565b90506139e960608301846149b7565b5f60208284031215614a0d575f80fd5b5051919050565b828152604081016112eb60208301846149b7565b606081525f614a3a606083018661493a565b602083820381850152614a4d8287613f24565b915083820360408501528185518084528284019150828160051b8501018388015f5b83811015614a9d57601f19878403018552614a8b838351613f24565b94860194925090850190600101614a6f565b50909a995050505050505050505056feed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600ed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea601a164736f6c6343000818000a",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b5060043610610269575f3560e01c806389a3027111610157578063b1620616116100d2578063c960a32411610088578063f2fde38b1161006e578063f2fde38b1461075a578063f800ece91461076d578063f887ea4014610782575f80fd5b8063c960a32414610716578063e52028d514610738575f80fd5b8063b35876e7116100b8578063b35876e7146106c8578063b9642260146106db578063c750f8fd14610703575f80fd5b8063b162061614610527578063b32c4d8d14610620575f80fd5b80639559c0bd116101275780639bd129691161010d5780639bd12969146104d35780639f4a323e146104f2578063a6c3be1314610505575f80fd5b80639559c0bd146104a95780639ac2a011146104b1575f80fd5b806389a30271146104375780638c2e02de1461045e5780638da5cb5b146104715780638e2de4d314610481575f80fd5b80635947fa25116101e7578063792f8a0c116101b757806380d6664c1161019d57806380d6664c146103fe57806383589fde14610411578063882da1f114610424575f80fd5b8063792f8a0c146103ab5780637dc5ad37146103eb575f80fd5b80635947fa25146103685780635f8d26b2146103875780636579c99214610390578063715018a6146103a3575f80fd5b80631e3dd18b1161023c578063391a9e1111610222578063391a9e11146103235780633dc1d233146103365780634726a16014610355575f80fd5b80631e3dd18b146102ea5780632e1a7d4d14610310575f80fd5b80630311b02f1461026d5780631128f2221461029557806312ac9b46146102c25780631e1bff3f146102d5575b5f80fd5b61028061027b366004613ea3565b6107a9565b60405190151581526020015b60405180910390f35b6102b46102a3366004613ecb565b60106020525f908152604090205481565b60405190815260200161028c565b6102806102d0366004613ea3565b610847565b6102e86102e3366004613eef565b6108a6565b005b6102fd6102f8366004613ecb565b61090c565b60405161028c9796959493929190613f67565b6102e861031e366004613ecb565b610a84565b6102b4610331366004613fe3565b610b6b565b6102b4610344366004613ecb565b60126020525f908152604090205481565b6102806103633660046141f8565b611064565b6102b4610376366004613ecb565b600a6020525f908152604090205481565b6102b460055481565b61028061039e366004614244565b6112f2565b6102e86114c1565b6103d36103b9366004613ecb565b600b6020525f90815260409020546001600160a01b031681565b6040516001600160a01b03909116815260200161028c565b6102806103f93660046141f8565b6114d4565b6102e861040c366004613ecb565b61193d565b6102e861041f366004613ecb565b611ab1565b6102e86104323660046142af565b611b5c565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b6102e861046c366004613ecb565b6121fa565b5f546001600160a01b03166103d3565b6103d361048f366004613ecb565b60076020525f90815260409020546001600160a01b031681565b6102b4600a81565b6102806104bf366004614363565b600e6020525f908152604090205460ff1681565b6102b46104e1366004613ecb565b600d6020525f908152604090205481565b6102e861050036600461437c565b61242c565b610280610513366004613ecb565b60096020525f908152604090205460ff1681565b61060e610535366004613ecb565b600660208181525f92835260409283902080548451808601865260018301546001600160a01b0390811682526002840154811682860152865160a081018852600385015467ffffffffffffffff1681526004850154818701526005850154818901529584015460608088019190915260078501546080808901919091528851908101895260088601548152600986015481880152600a860154818a0152600b86015491810191909152600c8501548851808a01909952600d8601548952600e9095015495880195909552909116949093929160ff169086565b60405161028c969594939291906143d5565b61068361062e366004613ecb565b60116020525f90815260409020805460018201546002830154600484015460059094015492936001600160a01b0392831693929091169167ffffffffffffffff81169068010000000000000000900460ff1686565b604080519687526001600160a01b0395861660208801529390941692850192909252606084015267ffffffffffffffff166080830152151560a082015260c00161028c565b6102e86106d6366004613ecb565b612ae5565b6103d36106e9366004613ecb565b60086020525f90815260409020546001600160a01b031681565b610280610711366004614244565b612b8a565b610280610724366004613ecb565b600c6020525f908152604090205460ff1681565b610280610746366004613ecb565b60026020525f908152604090205460ff1681565b6102e8610768366004614363565b612ec7565b610775612f01565b60405161028c9190614494565b6103d37f000000000000000000000000000000000000000000000000000000000000000081565b60405163a9059cbb60e01b81526001600160a01b038381166004830152602482018390525f917f00000000000000000000000000000000000000000000000000000000000000009091169063a9059cbb906044015b6020604051808303815f875af115801561081a573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061083e919061456e565b90505b92915050565b6040516323b872dd60e01b81526001600160a01b038381166004830152306024830152604482018390525f917f0000000000000000000000000000000000000000000000000000000000000000909116906323b872dd906064016107fe565b6108ae6130e0565b6001600160a01b0382165f818152600e6020908152604091829020805460ff191685151590811790915591519182527f278b09622564dd3991fe7744514513d64ea2c8ed2b2b9ec1150ad964fde80a99910160405180910390a25050565b6004818154811061091b575f80fd5b5f918252602090912060059091020180546001820180546001600160a01b0390921693509061094990614589565b80601f016020809104026020016040519081016040528092919081815260200182805461097590614589565b80156109c05780601f10610997576101008083540402835291602001916109c0565b820191905f5260205f20905b8154815290600101906020018083116109a357829003601f168201915b505050506002830154600384018054939460ff8316946101009093046001600160a01b03169350916109f190614589565b80601f0160208091040260200160405190810160405280929190818152602001828054610a1d90614589565b8015610a685780601f10610a3f57610100808354040283529160200191610a68565b820191905f5260205f20905b815481529060010190602001808311610a4b57829003601f168201915b5050506004909301549192505060ff8082169161010090041687565b5f81815260066020526040902080546001600160a01b0316610ac157604051633582fa3760e11b8152600481018390526024015b60405180910390fd5b80546001600160a01b03163314610aff57805460405163833ce3c560e01b81523360048201526001600160a01b039091166024820152604401610ab8565b6040805160018082528183019092525f916020808301908036833701905050600b830154909150815f81518110610b3857610b386145c1565b60209081029190910101525f610b5582630239350b60e51b61310c565b5f90815260136020526040902093909355505050565b5f60025f7f00000000000000000000000000000000000000000000000000000000000000008b604051602001610bb79291906001600160a01b0392831681529116602082015260400190565b60408051601f198184030181529181528151602092830120835290820192909252015f205460ff16610c2f576040516368bd6d4960e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000811660048301528a166024820152604401610ab8565b5f610c6f8685858080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061311892505050565b90505f610cb18686868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061311892505050565b90505f610cf38a87878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061311892505050565b90505f610d358a88888080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061311892505050565b600580549192505f610d46836145e9565b9190505594505f60065f8781526020019081526020015f20905033815f015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055507f0000000000000000000000000000000000000000000000000000000000000000816001015f015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055508d816001016001015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055508c816003015f015f6101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550828160030160010181905550848160080160020181905550838160030160030181905550610e555f613125565b6007820155610e635f613125565b600b820155610e715f613125565b60058201556008810182905560098101829055600c8101805460ff19169055600e8101869055600a810154610ea59061313b565b506006810154610eb49061313b565b506007810154610ec39061313b565b50600b810154610ed29061313b565b506004810154610ee19061313b565b506008810154610ef09061313b565b506005810154610eff9061313b565b506009810154610f0e9061313b565b50600a810154610f1e903361314a565b506006810154610f2e903361314a565b506007810154610f3e903361314a565b50600b810154610f4e903361314a565b506004810154610f5e903361314a565b506008810154610f6e903361314a565b506005810154610f7e903361314a565b506009810154610f8e903361314a565b506040805160018082528183019092525f916020808301908036833701905050905082815f81518110610fc357610fc36145c1565b60209081029190910101525f610fe08263c750f8fd60e01b61310c565b5f81815260076020908152604080832080546001600160a01b03199081163390811790925560088452828520805490911630179055600a9092528083208c9055600d870184905551929350918a917f6b67a01eb500680a90226d64ad9239c6dc9c95b64ea6a8d9a3b5b94197b4658591a35050505050505098975050505050505050565b5f838152601360205260408120548082036110955760405163261c57d160e21b815260048101869052602401610ab8565b61109f858461315c565b5f818152600660208181526040808420815160c08101835281546001600160a01b0390811682528351808501855260018401548216815260028401549091168186015281850152825160a081018452600383015467ffffffffffffffff16815260048084015482870152600584015482860152958301546060808301919091526007840154608080840191909152838601929092528451808301865260088501548152600985015496810196909652600a84015494860194909452600b8301548585015292810193909352600c810154929390929184019160ff169081111561118a5761118a6143ad565b600481111561119b5761119b6143ad565b8152604080518082018252600d8401548152600e90930154602080850191909152918201929092528281015101518251915163a9059cbb60e01b81526001600160a01b03928316600482015260248101899052929350919082169063a9059cbb906044016020604051808303815f875af1925050508015611239575060408051601f3d908101601f191682019092526112369181019061456e565b60015b6112a757611245614601565b806308c379a003611281575061125961461a565b806112645750611283565b818160405163c29d9e4760e01b8152600401610ab89291906146a3565b505b60405163fa347b2160e01b81526001600160a01b0382166004820152602401610ab8565b806112e25782516040516307a1d48760e01b81526001600160a01b038085166004830152909116602482015260448101889052606401610ab8565b50600193505050505b9392505050565b5f838152600c602052604081205460ff161561132457604051636c0a991f60e01b815260048101859052602401610ab8565b5f848152600b60205260409020546001600160a01b0316611345858461315c565b5f858152600c60209081526040808320805460ff19166001179055600d82528083205483526006909152908190209051630311b02f60e01b81526001600160a01b038316600482015267ffffffffffffffff86166024820181905291903090630311b02f906044016020604051808303815f875af19250505080156113e7575060408051601f3d908101601f191682019092526113e49181019061456e565b60015b611468576113f3614601565b806308c379a003611435575061140761461a565b806114125750611437565b5f600d830155604051631033c5ff60e31b8152610ab890859083906004016146a3565b505b5f600d820155604051630c0ab95b60e21b81526001600160a01b038416600482015260248101839052604401610ab8565b8061149e575f600d8301556040516357b9d85960e11b81526001600160a01b038516600482015260248101849052604401610ab8565b50600c8101805460ff191660041790555f600d9091015550600191506112eb9050565b6114c96130e0565b6114d25f6131c3565b565b5f8381526012602052604081205480820361150557604051636611701960e11b815260048101869052602401610ab8565b61150f858461315c565b5f818152601160205260409020600581015468010000000000000000900460ff161561155157604051632dd7dfe360e11b815260048101839052602401610ab8565b845f8190036115765760405163967d723360e01b815260048101849052602401610ab8565b6040805160028082526060820183525f92602083019080368337505050600184015481519192506001600160a01b03169082905f906115b7576115b76145c1565b6001600160a01b03928316602091820292909201015260028401548251911690829060019081106115ea576115ea6145c1565b6001600160a01b039283166020918202929092010152600184015460405163095ea7b360e01b81527f0000000000000000000000000000000000000000000000000000000000000000831660048201525f602482015291169063095ea7b3906044016020604051808303815f875af1158015611668573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061168c919061456e565b50600183015460405163095ea7b360e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166004830152602482018590529091169063095ea7b3906044016020604051808303815f875af11580156116ff573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611723919061456e565b506040516338ed173960e01b81525f906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906338ed17399061177a90869085908790309042906004016146c4565b5f604051808303815f875af1158015611795573d5f803e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526117bc9190810190614735565b90505f81600183516117ce91906147c1565b815181106117de576117de6145c1565b602002602001015190505f6117f282613125565b90506117fd8161313b565b5060038601545f5b818110156118d0575f886006018281548110611823576118236145c1565b905f5260205f20015490505f6118398583613212565b90506118448161313b565b505f611850828b613240565b90505f60065f8d600301878154811061186b5761186b6145c1565b905f5260205f20015481526020019081526020015f209050611894816008016003015483613266565b600b82018190556118a49061313b565b50600b81015481546118bf91906001600160a01b031661314a565b505060019093019250611805915050565b5060058701805468ff0000000000000000191668010000000000000000179055604080518781526020810185905289917f2403003b183ff811dedab647749b7525f94e39ff05e4a7b4f02743c21b6c1622910160405180910390a25060019b9a5050505050505050505050565b5f81815260066020526040902080546001600160a01b0316331461198857805460405163833ce3c560e01b81523360048201526001600160a01b039091166024820152604401610ab8565b6004600c82015460ff1660048111156119a3576119a36143ad565b14806119c757506003600c82015460ff1660048111156119c5576119c56143ad565b145b156119f157600c810154604051630163d0b760e41b8152610ab89160ff16906001906004016147d4565b6040805160018082528183019092525f9160208083019080368337019050506009830154909150815f81518110611a2a57611a2a6145c1565b60209081029190910101525f611a47826332bce4c960e11b61310c565b5f818152600b6020908152604080832080546001600160a01b03191633179055600c8252808320805460ff19169055600d9091528082208790555191925085917f09f4c2fd13cc57768b21af5847536074d3fab1d1dfe1e382d9259c516945ea6d9190a250505050565b5f81815260066020526040902080546001600160a01b03163314611afc57805460405163833ce3c560e01b81523360048201526001600160a01b039091166024820152604401610ab8565b6001600c82015460ff166004811115611b1757611b176143ad565b14611b4157600c810154604051630163d0b760e41b8152610ab89160ff16906001906004016147d4565b600c810180546002919060ff19166001835b02179055505050565b611b646130e0565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316876001600160a01b031614611be957604051638a26cfc960e01b81526001600160a01b0380891660048301527f0000000000000000000000000000000000000000000000000000000000000000166024820152604401610ab8565b604080516001600160a01b03808a1660208301528616918101919091525f9060600160408051808303601f1901815291815281516020928301205f81815260029093529120805460ff19168415801591909117909155909150611dde575f8181526003602052604090205415611c74576040516249063560e61b815260048101829052602401610ab8565b6040805160e0810182526001600160a01b038a81168252602082018a815260ff8a81169484019490945288821660608401526080830188905292861660a083015284151560c0830152600480546001810182555f9190915282517f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b600590920291820180546001600160a01b031916919093161782559251919290917f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19c90910190611d3f908261483b565b50604082015160028201805460608501516001600160a01b03166101000274ffffffffffffffffffffffffffffffffffffffffff1990911660ff9093169290921791909117905560808201516003820190611d9a908261483b565b5060a08201516004918201805460c09094015115156101000261ffff1990941660ff9092169190911792909217909155545f828152600360205260409020556121a1565b5f8181526003602052604081205490819003611e1057604051631fdc01bd60e21b815260048101839052602401610ab8565b600454818114612114575f6004611e286001846147c1565b81548110611e3857611e386145c1565b5f9182526020918290206040805160e0810190915260059092020180546001600160a01b031682526001810180549293919291840191611e7790614589565b80601f0160208091040260200160405190810160405280929190818152602001828054611ea390614589565b8015611eee5780601f10611ec557610100808354040283529160200191611eee565b820191905f5260205f20905b815481529060010190602001808311611ed157829003601f168201915b5050509183525050600282015460ff8116602083015261010090046001600160a01b03166040820152600382018054606090920191611f2c90614589565b80601f0160208091040260200160405190810160405280929190818152602001828054611f5890614589565b8015611fa35780601f10611f7a57610100808354040283529160200191611fa3565b820191905f5260205f20905b815481529060010190602001808311611f8657829003601f168201915b505050918352505060049182015460ff80821660208401526101009091041615156040909101529091508190611fda6001866147c1565b81548110611fea57611fea6145c1565b5f91825260209182902083516005929092020180546001600160a01b0319166001600160a01b0390921691909117815590820151600182019061202d908261483b565b50604082015160028201805460608501516001600160a01b03166101000274ffffffffffffffffffffffffffffffffffffffffff1990911660ff9093169290921791909117905560808201516003820190612088908261483b565b5060a08201516004909101805460c09093015115156101000261ffff1990931660ff909216919091179190911790558051606082015160405185926003925f926120eb9291906020016001600160a01b0392831681529116602082015260400190565b6040516020818303038152906040528051906020012081526020019081526020015f2081905550505b6004805480612125576121256148fb565b5f8281526020812060055f199093019283020180546001600160a01b0319168155906121546001830182613dfc565b60028201805474ffffffffffffffffffffffffffffffffffffffffff19169055612181600383015f613dfc565b50600401805461ffff19169055905550505f818152600360205260408120555b846001600160a01b0316886001600160a01b03167fa0be238839c65552a544da5e66b7a224fe553eccb19681bc2ddd043f4ec863ce846040516121e8911515815260200190565b60405180910390a35050505050505050565b612202613294565b5f81815260066020526040812090600c82015460ff166004811115612229576122296143ad565b1461225257600c810154604051630163d0b760e41b8152610ab89160ff16905f906004016147d4565b80546001600160a01b0316331461229057805460405163833ce3c560e01b81523360048201526001600160a01b039091166024820152604401610ab8565b60018101547f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161461231b576001810154604051638a26cfc960e01b81526001600160a01b0391821660048201527f00000000000000000000000000000000000000000000000000000000000000009091166024820152604401610ab8565b600d8101541561234757600d810154604051633cbec87360e11b81526004810191909152602401610ab8565b6040805160018082528183019092525f9160208083019080368337019050506008830154909150815f81518110612380576123806145c1565b60209081029190910101525f61239d8263c750f8fd60e01b61310c565b5f81815260076020908152604080832080546001600160a01b03199081163317909155600880845282852080549092163017909155600a835292819020889055600d870184905591860154915191825291925085917f58f5b348d768706eb06a6b936c1693225c21d718ba68427539112fc61c4c824f910160405180910390a250505061242960018055565b50565b604080516001600160a01b0380851660208301528316918101919091525f9060600160408051601f1981840301815291815281516020928301205f818152600290935291205490915060ff166124a8576040516368bd6d4960e01b81526001600160a01b03808516600483015283166024820152604401610ab8565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316836001600160a01b03161461252d57604051638a26cfc960e01b81526001600160a01b0380851660048301527f0000000000000000000000000000000000000000000000000000000000000000166024820152604401610ab8565b425f61253882613125565b60408051600a80825261016082019092529192505f919060208201610140803683370190505090505f8061256b5f613125565b60408051600a80825261016082019092529192505f919060208201610140803683375050505f88815260106020526040902054909150805b600554811080156125b45750600a85105b156127c7575f8181526006602052604090206001600c82015460ff1660048111156125e1576125e16143ad565b146125ec57506127b5565b60018101546001600160a01b038d811691161461260957506127b5565b60028101546001600160a01b038c811691161461262657506127b5565b60038101545f9061264b908a906126469067ffffffffffffffff16613125565b6132be565b90505f612666836003016004015484600301600301546132ec565b90505f612673838361331a565b90505f61268e856008016001015486600801600201546132ec565b90505f6126aa8287600801600101548860080160020154613348565b90505f6126c084836126bb5f613125565b613348565b90506126cc8b82613266565b9a506126df87600801600101548261335c565b600988018190556126ef9061313b565b506009870154875461270a91906001600160a01b031661314a565b505f6127238561271a6001613125565b6126bb5f613125565b9050612736886003016004015482613266565b600789018190556127469061313b565b506007880154885461276191906001600160a01b031661314a565b50888e8e81518110612775576127756145c1565b602002602001018181525050818b8e81518110612794576127946145c1565b60209081029190910101528c6127a9816145e9565b9d505050505050505050505b806127bf816145e9565b9150506125a3565b506127d2848261490f565b5f898152601060205260409020819055600554116127f9575f888152601060205260408120555b835f0361281c576040516368c7f07560e11b815260048101899052602401610ab8565b5f8467ffffffffffffffff81111561283657612836614094565b60405190808252806020026020018201604052801561285f578160200160208202803683370190505b5090505f8567ffffffffffffffff81111561287c5761287c614094565b6040519080825280602002602001820160405280156128a5578160200160208202803683370190505b5090505f5b8681101561294d578781815181106128c4576128c46145c1565b60200260200101518382815181106128de576128de6145c1565b6020026020010181815250508481815181106128fc576128fc6145c1565b6020026020010151828281518110612916576129166145c1565b602002602001018181525050612944828281518110612937576129376145c1565b602002602001015161313b565b506001016128aa565b50600f80545f918261295e836145e9565b9190505590505f60115f8381526020019081526020015f20905081815f01819055508d816001015f6101000a8154816001600160a01b0302191690836001600160a01b031602179055508c816002015f6101000a8154816001600160a01b0302191690836001600160a01b03160217905550838160030190805190602001906129e8929190613e33565b5082516129fe9060068301906020860190613e33565b506004810187905560058101805468ffffffffffffffffff191667ffffffffffffffff8d161790556040805160018082528183019092525f916020808301908036833701905050905087815f81518110612a5a57612a5a6145c1565b60209081029190910101525f612a7782637dc5ad3760e01b61310c565b90508360125f8381526020019081526020015f20819055508e6001600160a01b0316847f4e8b671325df0fa1bd467eba25b6137a2055be9cd84a626c78581cfb12a94f5e8c604051612acb91815260200190565b60405180910390a350505050505050505050505050505050565b5f81815260066020526040902080546001600160a01b03163314612b3057805460405163833ce3c560e01b81523360048201526001600160a01b039091166024820152604401610ab8565b6002600c82015460ff166004811115612b4b57612b4b6143ad565b14612b7557600c810154604051630163d0b760e41b8152610ab89160ff16906002906004016147d4565b600c810180546001919060ff19168280611b53565b5f8381526009602052604081205460ff1615612bbc576040516301c4fa3d60e51b815260048101859052602401610ab8565b5f848152600760209081526040808320546008909252909120546001600160a01b039182169116612bed868561315c565b5f868152600960209081526040808320805460ff19166001179055600a825280832054835260069091529020600d81015467ffffffffffffffff871691908814612c5357600d810154604051633cbec87360e11b81526004810191909152602401610ab8565b5f600d8201556040516309564da360e11b81526001600160a01b03851660048201526024810183905230906312ac9b46906044016020604051808303815f875af1925050508015612cc1575060408051601f3d908101601f19168201909252612cbe9181019061456e565b60015b612dd857612ccd614601565b806308c379a003612d475750612ce161461a565b80612cec5750612d49565b836001600160a01b0316856001600160a01b03168a7faa7c343a6dcb357305f5cca178d1e5bcf74f1cece577e2f4ab98e7fc9759ba898685604051612d32929190614922565b60405180910390a45f955050505050506112eb565b505b826001600160a01b0316846001600160a01b0316897faa7c343a6dcb357305f5cca178d1e5bcf74f1cece577e2f4ab98e7fc9759ba8985604051612dc49181526040602082018190526015908201527f546f6b656e207472616e73666572206661696c65640000000000000000000000606082015260800190565b60405180910390a45f9450505050506112eb565b8015612e4057600c8201805460ff191660011790556040518381526001600160a01b0380861691908716908b907ff1b289f30d1499938643326e8dad1060509095ff97a300b4a36a9f0771c29e949060200160405180910390a46001955050505050506112eb565b836001600160a01b0316856001600160a01b03168a7faa7c343a6dcb357305f5cca178d1e5bcf74f1cece577e2f4ab98e7fc9759ba8986604051612d32918152604060208201819052601d908201527f546f6b656e207472616e736665722072657475726e65642066616c7365000000606082015260800190565b50505050509392505050565b612ecf6130e0565b6001600160a01b038116612ef857604051631e4fbdf760e01b81525f6004820152602401610ab8565b612429816131c3565b60606004805480602002602001604051908101604052809291908181526020015f905b828210156130d7575f8481526020908190206040805160e081019091526005850290910180546001600160a01b031682526001810180549293919291840191612f6c90614589565b80601f0160208091040260200160405190810160405280929190818152602001828054612f9890614589565b8015612fe35780601f10612fba57610100808354040283529160200191612fe3565b820191905f5260205f20905b815481529060010190602001808311612fc657829003601f168201915b5050509183525050600282015460ff8116602083015261010090046001600160a01b0316604082015260038201805460609092019161302190614589565b80601f016020809104026020016040519081016040528092919081815260200182805461304d90614589565b80156130985780601f1061306f57610100808354040283529160200191613098565b820191905f5260205f20905b81548152906001019060200180831161307b57829003601f168201915b50505091835250506004919091015460ff8082166020808501919091526101009092041615156040909201919091529082526001929092019101612f24565b50505050905090565b5f546001600160a01b031633146114d25760405163118cdaa760e01b8152336004820152602401610ab8565b5f61083e83835f61338a565b5f61083e838360056134c3565b5f6108418267ffffffffffffffff1660056135b1565b5f6131468230613640565b5090565b5f6131558383613640565b5090919050565b5f613166836136b6565b90505f6131738284613787565b9050806131935760405163cf6c44e960e01b815260040160405180910390fd5b60405184907f1af0453083661051f6e56e5c070792320652e612154bf9af8637bb1e7655b99d905f90a250505050565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b5f82613224576132215f613125565b92505b81613235576132325f613125565b91505b61083e83835f61388f565b5f826132525761324f5f613125565b92505b61083e8367ffffffffffffffff841661394c565b5f82613278576132755f613125565b92505b81613289576132865f613125565b91505b61083e83835f6139f2565b6002600154036132b757604051633ee5aeb560e01b815260040160405180910390fd5b6002600155565b5f826132d0576132cd5f613125565b92505b816132e1576132de5f613125565b91505b61083e83835f613a69565b5f826132fe576132fb5f613125565b92505b8161330f5761330c5f613125565b91505b61083e83835f613ae0565b5f8261332c576133295f613b57565b92505b8161333d5761333a5f613b57565b91505b61083e83835f613b72565b5f613354848484613be9565b949350505050565b5f8261336e5761336b5f613125565b92505b8161337f5761337c5f613125565b91505b61083e83835f613c45565b7f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d01545f80516020614aae8339815191528054604051637d6e912360e11b81527f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d0092916001600160a01b03169063fadd22469061340a908990600401614974565b5f604051808303815f87803b158015613421575f80fd5b505af1158015613433573d5f803e3d5ffd5b50508354604051633263b83b60e01b81526001600160a01b039091169250633263b83b9150869061346c9087908b908b90600401614986565b5f604051808303818588803b158015613483575f80fd5b505af1158015613495573d5f803e3d5ffd5b50505050506134a48387613cbc565b600182018054905f6134b5836145e9565b919050555050509392505050565b5f80516020614ace8339815191525460405163196d0b9b60e01b81525f915f80516020614aae833981519152916001600160a01b039091169063196d0b9b906135169088903390899089906004016149c7565b6020604051808303815f875af1158015613532573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061355691906149fd565b8154604051630f8e573b60e21b8152600481018390523360248201529193506001600160a01b031690633e395cec906044015f604051808303815f87803b15801561359f575f80fd5b505af1158015612ebb573d5f803e3d5ffd5b5f80516020614ace83398151915254604051639cd07acb60e01b81525f915f80516020614aae833981519152916001600160a01b0390911690639cd07acb906136009087908790600401614a14565b6020604051808303815f875af115801561361c573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061335491906149fd565b5f5f80516020614aae8339815191528054604051635ca4b5b160e11b8152600481018690526001600160a01b03858116602483015292935091169063b9496b62906044015f604051808303815f87803b15801561369b575f80fd5b505af11580156136ad573d5f803e3d5ffd5b50505050505050565b5f8181527f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d0260205260408120546060917f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d009190036137275760405163d66ca67560e01b815260040160405180910390fd5b5f8381526002820160209081526040918290208054835181840281018401909452808452909183018282801561377a57602002820191905f5260205f20905b815481526020019060010190808311613766575b5050505050915050919050565b5f60248161379485613d4f565b90505f8167ffffffffffffffff8111156137b0576137b0614094565b6040519080825280601f01601f1916602001820160405280156137da576020820181803683370190505b509050818360208301377fed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea60254604051632c027b1360e21b81525f80516020614aae833981519152916001600160a01b03169063b009ec4c90613844908a9086908b90600401614a28565b6020604051808303815f875af1158015613860573d5f803e3d5ffd5b505050506040513d601f19601f82011682018060405250810190613884919061456e565b979650505050505050565b5f8082156138a25750600160f81b6138a5565b505f5b5f80516020614ace83398151915254604051630afe14ad60e31b815260048101879052602481018690526001600160f81b0319831660448201525f80516020614aae833981519152916001600160a01b0316906357f0a568906064015b6020604051808303815f875af115801561391e573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061394291906149fd565b9695505050505050565b5f80516020614ace83398151915254604051635a53accb60e01b81526004810184905260248101839052600160f81b604482018190525f9290915f80516020614aae833981519152916001600160a01b031690635a53accb906064015b6020604051808303815f875af11580156139c5573d5f803e3d5ffd5b505050506040513d601f19601f820116820180604052508101906139e991906149fd565b95945050505050565b5f808215613a055750600160f81b613a08565b505f5b5f80516020614ace8339815191525460405163022f65e760e31b815260048101879052602481018690526001600160f81b0319831660448201525f80516020614aae833981519152916001600160a01b03169063117b2f3890606401613902565b5f808215613a7c5750600160f81b613a7f565b505f5b5f80516020614ace833981519152546040516385362ee760e01b815260048101879052602481018690526001600160f81b0319831660448201525f80516020614aae833981519152916001600160a01b0316906385362ee790606401613902565b5f808215613af35750600160f81b613af6565b505f5b5f80516020614ace83398151915254604051637210768160e01b815260048101879052602481018690526001600160f81b0319831660448201525f80516020614aae833981519152916001600160a01b031690637210768190606401613902565b5f61084182613b66575f613b69565b60015b60ff165f6135b1565b5f808215613b855750600160f81b613b88565b505f5b5f80516020614ace8339815191525460405163d99882d560e01b815260048101879052602481018690526001600160f81b0319831660448201525f80516020614aae833981519152916001600160a01b03169063d99882d590606401613902565b5f80516020614ace83398151915254604051637702dcff60e01b81526004810185905260248101849052604481018390525f915f80516020614aae833981519152916001600160a01b0390911690637702dcff906064016139a9565b5f808215613c585750600160f81b613c5b565b505f5b5f80516020614ace833981519152546040516303056db360e31b815260048101879052602481018690526001600160f81b0319831660448201525f80516020614aae833981519152916001600160a01b03169063182b6d9890606401613902565b5f8281527f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d0260205260409020547f5ea69329017273582817d320489fbd94f775580e90c092699ca6f3d12fdf7d009015613d2957604051633f06d22b60e01b815260040160405180910390fd5b5f83815260028201602090815260409091208351613d4992850190613e33565b50505050565b80515f9081805b82811015613df0575f858281518110613d7157613d716145c1565b6020026020010151601e60208110613d8b57613d8b6145c1565b1a6053811115613d9d57613d9d6143ad565b90506009816053811115613db357613db36143ad565b60ff161015613dce57613dc760208461490f565b9250613de7565b60405163ce54a8d160e01b815260040160405180910390fd5b50600101613d56565b5061335460208261490f565b508054613e0890614589565b5f825580601f10613e17575050565b601f0160209004905f5260205f20908101906124299190613e74565b828054828255905f5260205f20908101928215613e6c579160200282015b82811115613e6c578251825591602001919060010190613e51565b506131469291505b5b80821115613146575f8155600101613e75565b80356001600160a01b0381168114613e9e575f80fd5b919050565b5f8060408385031215613eb4575f80fd5b613ebd83613e88565b946020939093013593505050565b5f60208284031215613edb575f80fd5b5035919050565b8015158114612429575f80fd5b5f8060408385031215613f00575f80fd5b613f0983613e88565b91506020830135613f1981613ee2565b809150509250929050565b5f81518084525f5b81811015613f4857602081850181015186830182015201613f2c565b505f602082860101526020601f19601f83011685010191505092915050565b5f6001600160a01b03808a16835260e06020840152613f8960e084018a613f24565b60ff8916604085015281881660608501528381036080850152613fac8188613f24565b60ff9690961660a085015250505090151560c09091015295945050505050565b803567ffffffffffffffff81168114613e9e575f80fd5b5f805f805f805f8060e0898b031215613ffa575f80fd5b61400389613e88565b975061401160208a01613fcc565b965060408901359550606089013594506080890135935060a0890135925060c089013567ffffffffffffffff80821115614049575f80fd5b818b0191508b601f83011261405c575f80fd5b81358181111561406a575f80fd5b8c602082850101111561407b575f80fd5b6020830194508093505050509295985092959890939650565b634e487b7160e01b5f52604160045260245ffd5b601f8201601f1916810167ffffffffffffffff811182821017156140ce576140ce614094565b6040525050565b5f67ffffffffffffffff8211156140ee576140ee614094565b5060051b60200190565b5f67ffffffffffffffff83111561411157614111614094565b604051614128601f8501601f1916602001826140a8565b80915083815284848401111561413c575f80fd5b838360208301375f60208583010152509392505050565b5f82601f830112614162575f80fd5b8135602061416f826140d5565b6040805161417d83826140a8565b84815260059490941b860183019383810192508785111561419c575f80fd5b8387015b858110156141ec57803567ffffffffffffffff8111156141be575f80fd5b8801603f81018a136141ce575f80fd5b6141de8a878301358684016140f8565b8552509284019284016141a0565b50979650505050505050565b5f805f6060848603121561420a575f80fd5b8335925060208401359150604084013567ffffffffffffffff81111561422e575f80fd5b61423a86828701614153565b9150509250925092565b5f805f60608486031215614256575f80fd5b8335925061426660208501613fcc565b9150604084013567ffffffffffffffff81111561422e575f80fd5b5f82601f830112614290575f80fd5b61083e838335602085016140f8565b803560ff81168114613e9e575f80fd5b5f805f805f805f60e0888a0312156142c5575f80fd5b6142ce88613e88565b9650602088013567ffffffffffffffff808211156142ea575f80fd5b6142f68b838c01614281565b975061430460408b0161429f565b965061431260608b01613e88565b955060808a0135915080821115614327575f80fd5b506143348a828b01614281565b93505061434360a0890161429f565b915060c088013561435381613ee2565b8091505092959891949750929550565b5f60208284031215614373575f80fd5b61083e82613e88565b5f806040838503121561438d575f80fd5b61439683613e88565b91506143a460208401613e88565b90509250929050565b634e487b7160e01b5f52602160045260245ffd5b600581106143d1576143d16143ad565b9052565b5f6101e0820190506001600160a01b0380891683528088511660208401528060208901511660408401525067ffffffffffffffff865116606083015260208601516080830152604086015160a0830152606086015160c0830152608086015160e0830152614468610100830186805182526020810151602083015260408101516040830152606081015160608301525050565b6144766101808301856143c1565b82516101a083015260208301516101c0830152979650505050505050565b5f60208083018184528085518083526040925060408601915060408160051b8701018488015f5b8381101561456057603f19898403018552815160e06001600160a01b0380835116865289830151828b8801526144f383880182613f24565b92505060ff8984015116898701526060818185015116818801525050608080830151868303828801526145268382613f24565b9250505060a08083015161453e8288018260ff169052565b505060c0918201511515949091019390935293860193908601906001016144bb565b509098975050505050505050565b5f6020828403121561457e575f80fd5b81516112eb81613ee2565b600181811c9082168061459d57607f821691505b6020821081036145bb57634e487b7160e01b5f52602260045260245ffd5b50919050565b634e487b7160e01b5f52603260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b5f600182016145fa576145fa6145d5565b5060010190565b5f60033d11156146175760045f803e505f5160e01c5b90565b5f60443d10156146275790565b6040516003193d81016004833e81513d67ffffffffffffffff816024840111818411171561465757505050505090565b828501915081518181111561466f5750505050505090565b843d87010160208285010111156146895750505050505090565b614698602082860101876140a8565b509095945050505050565b6001600160a01b0383168152604060208201525f6133546040830184613f24565b5f60a08201878352602087602085015260a0604085015281875180845260c0860191506020890193505f5b818110156147145784516001600160a01b0316835293830193918301916001016146ef565b50506001600160a01b03969096166060850152505050608001529392505050565b5f6020808385031215614746575f80fd5b825167ffffffffffffffff81111561475c575f80fd5b8301601f8101851361476c575f80fd5b8051614777816140d5565b60405161478482826140a8565b82815260059290921b83018401918481019150878311156147a3575f80fd5b928401925b82841015613884578351825292840192908401906147a8565b81810381811115610841576108416145d5565b604081016147e282856143c1565b6112eb60208301846143c1565b601f82111561483657805f5260205f20601f840160051c810160208510156148145750805b601f840160051c820191505b81811015614833575f8155600101614820565b50505b505050565b815167ffffffffffffffff81111561485557614855614094565b614869816148638454614589565b846147ef565b602080601f83116001811461489c575f84156148855750858301515b5f19600386901b1c1916600185901b1785556148f3565b5f85815260208120601f198616915b828110156148ca578886015182559484019460019091019084016148ab565b50858210156148e757878501515f19600388901b60f8161c191681555b505060018460011b0185555b505050505050565b634e487b7160e01b5f52603160045260245ffd5b80820180821115610841576108416145d5565b828152604060208201525f6133546040830184613f24565b5f815180845260208085019450602084015f5b838110156149695781518752958201959082019060010161494d565b509495945050505050565b602081525f61083e602083018461493a565b838152606060208201525f61499e606083018561493a565b905063ffffffff60e01b83166040830152949350505050565b605481106143d1576143d16143ad565b8481526001600160a01b0384166020820152608060408201525f6149ee6080830185613f24565b90506139e960608301846149b7565b5f60208284031215614a0d575f80fd5b5051919050565b828152604081016112eb60208301846149b7565b606081525f614a3a606083018661493a565b602083820381850152614a4d8287613f24565b915083820360408501528185518084528284019150828160051b8501018388015f5b83811015614a9d57601f19878403018552614a8b838351613f24565b94860194925090850190600101614a6f565b50909a995050505050505050505056feed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea600ed8d60e34876f751cc8b014c560745351147d9de11b9347c854e881b128ea601a164736f6c6343000818000a",
  "devdoc": {
    "errors": {
      "OwnableInvalidOwner(address)": [
        {
          "details": "The owner is not a valid owner account. (eg. `address(0)`)"
        }
      ],
      "OwnableUnauthorizedAccount(address)": [
        {
          "details": "The caller account is not authorized to perform an operation."
        }
      ],
      "ReentrancyGuardReentrantCall()": [
        {
          "details": "Unauthorized reentrant call."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "_escrow(address,uint256)": {
        "details": "Externalized transfer to keep a clean try/catch surface."
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "HandlesAlreadySavedForRequestID()": [
        {
          "notice": "Returned if some handles were already saved for corresponding ID."
        }
      ],
      "InvalidKMSSignatures()": [
        {
          "notice": "Returned if the returned KMS signatures are not valid."
        }
      ],
      "NoHandleFoundForRequestID()": [
        {
          "notice": "Returned if there was not handle found for the requested ID."
        }
      ],
      "UnsupportedHandleType()": [
        {
          "notice": "Returned if the requested handle to be decrypted is not of a supported type."
        }
      ]
    },
    "events": {
      "DecryptionFulfilled(uint256)": {
        "notice": "This event is emitted when requested decryption has been fulfilled."
      }
    },
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 39118,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 39376,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "_status",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 39905,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "allowedPairs",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_bytes32,t_bool)"
      },
      {
        "astId": 39909,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "pairIndex",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_bytes32,t_uint256)"
      },
      {
        "astId": 39913,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "allPairs",
        "offset": 0,
        "slot": "4",
        "type": "t_array(t_struct(Pair)42559_storage)dyn_storage"
      },
      {
        "astId": 40086,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "nextPlanId",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 40091,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "plans",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_uint256,t_struct(Plan)42619_storage)"
      },
      {
        "astId": 40095,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "requestIdToSender",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 40099,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "requestIdToRecipient",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 40103,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "requestProcessed",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_uint256,t_bool)"
      },
      {
        "astId": 40107,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "requestIdToPlanId",
        "offset": 0,
        "slot": "10",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 40952,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "cancelReqIdToSender",
        "offset": 0,
        "slot": "11",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 40956,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "cancelRequestProcessed",
        "offset": 0,
        "slot": "12",
        "type": "t_mapping(t_uint256,t_bool)"
      },
      {
        "astId": 40960,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "cancelRequestIdToPlanId",
        "offset": 0,
        "slot": "13",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 41217,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "executors",
        "offset": 0,
        "slot": "14",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 41349,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "nextBatchId",
        "offset": 0,
        "slot": "15",
        "type": "t_uint256"
      },
      {
        "astId": 41353,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "pairBatchCursor",
        "offset": 0,
        "slot": "16",
        "type": "t_mapping(t_bytes32,t_uint256)"
      },
      {
        "astId": 41358,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "batches",
        "offset": 0,
        "slot": "17",
        "type": "t_mapping(t_uint256,t_struct(Batch)42542_storage)"
      },
      {
        "astId": 41362,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "batchReqIdToBatchId",
        "offset": 0,
        "slot": "18",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 42147,
        "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
        "label": "withdrawReqToPlanId",
        "offset": 0,
        "slot": "19",
        "type": "t_mapping(t_uint256,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_struct(Pair)42559_storage)dyn_storage": {
        "base": "t_struct(Pair)42559_storage",
        "encoding": "dynamic_array",
        "label": "struct Pair[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_array(t_userDefinedValueType(euint64)42645)dyn_storage": {
        "base": "t_userDefinedValueType(euint64)42645",
        "encoding": "dynamic_array",
        "label": "euint64[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_enum(PlanStatus)42625": {
        "encoding": "inplace",
        "label": "enum PlanStatus",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes32,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_struct(Batch)42542_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Batch)",
        "numberOfBytes": "32",
        "value": "t_struct(Batch)42542_storage"
      },
      "t_mapping(t_uint256,t_struct(Plan)42619_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Plan)",
        "numberOfBytes": "32",
        "value": "t_struct(Plan)42619_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Batch)42542_storage": {
        "encoding": "inplace",
        "label": "struct Batch",
        "members": [
          {
            "astId": 42523,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "batchId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 42525,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "fromToken",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 42527,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "toToken",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 42530,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "planIds",
            "offset": 0,
            "slot": "3",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 42533,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "totalInEnc",
            "offset": 0,
            "slot": "4",
            "type": "t_userDefinedValueType(euint64)42645"
          },
          {
            "astId": 42535,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "slotTime",
            "offset": 0,
            "slot": "5",
            "type": "t_uint64"
          },
          {
            "astId": 42537,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "executed",
            "offset": 8,
            "slot": "5",
            "type": "t_bool"
          },
          {
            "astId": 42541,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "encryptedShares",
            "offset": 0,
            "slot": "6",
            "type": "t_array(t_userDefinedValueType(euint64)42645)dyn_storage"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_struct(Pair)42559_storage": {
        "encoding": "inplace",
        "label": "struct Pair",
        "members": [
          {
            "astId": 42546,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "from",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 42548,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "fromName",
            "offset": 0,
            "slot": "1",
            "type": "t_string_storage"
          },
          {
            "astId": 42550,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "fromDecimals",
            "offset": 0,
            "slot": "2",
            "type": "t_uint8"
          },
          {
            "astId": 42552,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "to",
            "offset": 1,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 42554,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "toName",
            "offset": 0,
            "slot": "3",
            "type": "t_string_storage"
          },
          {
            "astId": 42556,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "toDecimals",
            "offset": 0,
            "slot": "4",
            "type": "t_uint8"
          },
          {
            "astId": 42558,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "allowed",
            "offset": 1,
            "slot": "4",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(Plan)42619_storage": {
        "encoding": "inplace",
        "label": "struct Plan",
        "members": [
          {
            "astId": 42603,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 42606,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "tokens",
            "offset": 0,
            "slot": "1",
            "type": "t_struct(PlanTokens)42601_storage"
          },
          {
            "astId": 42609,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "timing",
            "offset": 0,
            "slot": "3",
            "type": "t_struct(PlanTiming)42583_storage"
          },
          {
            "astId": 42612,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "amounts",
            "offset": 0,
            "slot": "8",
            "type": "t_struct(PlanAmounts)42596_storage"
          },
          {
            "astId": 42615,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "status",
            "offset": 0,
            "slot": "12",
            "type": "t_enum(PlanStatus)42625"
          },
          {
            "astId": 42618,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "meta",
            "offset": 0,
            "slot": "13",
            "type": "t_struct(PlanMeta)42568_storage"
          }
        ],
        "numberOfBytes": "480"
      },
      "t_struct(PlanAmounts)42596_storage": {
        "encoding": "inplace",
        "label": "struct PlanAmounts",
        "members": [
          {
            "astId": 42586,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "totalAmount",
            "offset": 0,
            "slot": "0",
            "type": "t_userDefinedValueType(euint64)42645"
          },
          {
            "astId": 42589,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "remainingAmount",
            "offset": 0,
            "slot": "1",
            "type": "t_userDefinedValueType(euint64)42645"
          },
          {
            "astId": 42592,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "amountPerInterval",
            "offset": 0,
            "slot": "2",
            "type": "t_userDefinedValueType(euint64)42645"
          },
          {
            "astId": 42595,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "pendingOut",
            "offset": 0,
            "slot": "3",
            "type": "t_userDefinedValueType(euint64)42645"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_struct(PlanMeta)42568_storage": {
        "encoding": "inplace",
        "label": "struct PlanMeta",
        "members": [
          {
            "astId": 42565,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "requestId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 42567,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "planId",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(PlanTiming)42583_storage": {
        "encoding": "inplace",
        "label": "struct PlanTiming",
        "members": [
          {
            "astId": 42570,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "startTime",
            "offset": 0,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 42573,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "interval",
            "offset": 0,
            "slot": "1",
            "type": "t_userDefinedValueType(euint64)42645"
          },
          {
            "astId": 42576,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "lastExecutionTime",
            "offset": 0,
            "slot": "2",
            "type": "t_userDefinedValueType(euint64)42645"
          },
          {
            "astId": 42579,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "totalIntervals",
            "offset": 0,
            "slot": "3",
            "type": "t_userDefinedValueType(euint64)42645"
          },
          {
            "astId": 42582,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "executedIntervals",
            "offset": 0,
            "slot": "4",
            "type": "t_userDefinedValueType(euint64)42645"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(PlanTokens)42601_storage": {
        "encoding": "inplace",
        "label": "struct PlanTokens",
        "members": [
          {
            "astId": 42598,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "fromToken",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 42600,
            "contract": "contracts/ConfidentialDCABatch.sol:ConfidentialDCABatch",
            "label": "toToken",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      },
      "t_userDefinedValueType(euint64)42645": {
        "encoding": "inplace",
        "label": "euint64",
        "numberOfBytes": "32"
      }
    }
  }
}